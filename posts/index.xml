<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on FZxiao 的大仓库</title><link>https://fzxiao.top/posts/</link><description>Recent content in Posts on FZxiao 的大仓库</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Wed, 25 Nov 2020 14:48:34 +0800</lastBuildDate><atom:link href="https://fzxiao.top/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>剑指Offer 03 数组中的重复数字</title><link>https://fzxiao.top/posts/offer-03/</link><pubDate>Wed, 25 Nov 2020 14:48:34 +0800</pubDate><guid>https://fzxiao.top/posts/offer-03/</guid><description>题目 找出数组中重复的数字。
在一个长度为 n 的数组 nums 里的所有数字都在 0～n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次。请找出数组中任意一个重复的数字。
示例 1：
输入： [2, 3, 1, 0, 2, 5, 3] 输出：2 或 3 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/shu-zu-zhong-zhong-fu-de-shu-zi-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
一解(排序法) 先将数组排序，那么重复的数字必然排在一起
class Solution { public int findRepeatNumber(int[] nums) { Arrays.sort(nums); for(int i = 1; i &amp;lt; nums.length; i++) { if(nums[i] == nums[i-1]) { return nums[i]; } } return -1; } } 对应数组法 构造一个新数组，用于存储已经找到的值
如果值已存在，那该数重复
class Solution { public int findRepeatNumber(int[] nums) { int[] mapNums = new int[nums.</description></item><item><title>剑指Offer 05 替换空格——StringBuilder的应用</title><link>https://fzxiao.top/posts/offer-05/</link><pubDate>Wed, 25 Nov 2020 14:46:31 +0800</pubDate><guid>https://fzxiao.top/posts/offer-05/</guid><description>题目 请实现一个函数，把字符串 s 中的每个空格替换成&amp;quot;%20&amp;quot;。
 示例 1：
输入：s = &amp;quot;We are happy.&amp;quot; 输出：&amp;quot;We%20are%20happy.&amp;quot; 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/ti-huan-kong-ge-lcof 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
题解 利用 StringBuilder 来构造字符串
如果对应字符为' ' 则换为 &amp;ldquo;%20&amp;rdquo;
class Solution { public String replaceSpace(String s) { var sb = new StringBuilder(); for(int i = 0; i &amp;lt; s.length(); i++) { if(s.charAt(i) != &amp;#39; &amp;#39;) { sb.append(s.charAt(i)); } else { sb.append(&amp;#34;%20&amp;#34;); } } return sb.toString(); } }</description></item><item><title>剑指 Offer 06. 从尾到头打印链表</title><link>https://fzxiao.top/posts/offer-06/</link><pubDate>Sat, 21 Nov 2020 15:37:05 +0800</pubDate><guid>https://fzxiao.top/posts/offer-06/</guid><description>题目 输入一个链表的头节点，从尾到头反过来返回每个节点的值（用数组返回）。
示例 1：
输入：head = [1,3,2] 输出：[2,3,1] 一解(辅助栈法) 思路简单，栈先进后出
将元素全放入栈后
在取出放入打印数组中
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public int[] reversePrint(ListNode head) { Stack&amp;lt;Integer&amp;gt; stack = new Stack&amp;lt;Integer&amp;gt;(); for(ListNode p = head; p != null; p = p.next) { stack.push(p.val); } int size = stack.</description></item><item><title>Leetcode 206 反转链表</title><link>https://fzxiao.top/posts/leetcode-206/</link><pubDate>Sat, 21 Nov 2020 14:59:58 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-206/</guid><description>题目 反转一个单链表。
示例:
输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL 输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL 进阶:
你可以迭代或递归地反转链表。你能否用两种方法解决这道题？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/reverse-linked-list 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
一解(迭代法) 使用一个辅助栈
先将链表内所有节点放入辅助栈中，因为栈是先入后出的，所以在取出的时候能够自然的将链表反转
/** * Definition for singly-linked list. * public class ListNode { * int val; * ListNode next; * ListNode(int x) { val = x; } * } */ class Solution { public ListNode reverseList(ListNode head) { if(head == null || head.next == null) { return head; } Stack&amp;lt;ListNode&amp;gt; stack = new Stack&amp;lt;ListNode&amp;gt;(); for(ListNode p = head; p !</description></item><item><title>Leetcode 160 相交链表</title><link>https://fzxiao.top/posts/leetcode-160/</link><pubDate>Wed, 18 Nov 2020 15:12:57 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-160/</guid><description>题目 编写一个程序，找到两个单链表相交的起始节点。
注意：
如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存 示例 1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
题解 一解 稍加分析，想到了两种方法
一是用 HashMap 边遍历边存节点，然后判断节点是否出现在 HashMap 中</description></item><item><title>Leetcode 141 环形链表——龟兔赛跑算法的应用</title><link>https://fzxiao.top/posts/leetcode-141/</link><pubDate>Wed, 18 Nov 2020 14:36:31 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-141/</guid><description>龟兔赛跑算法（Floyd 判圈算法） 假想有 乌龟 和 兔子 在链表上移动，兔子跑得快，乌龟跑得慢
如果乌龟和兔子均从链表上的同一个节点开始运动
当该链表有环时，兔子由于跑的快，会先进入环内开始循环，乌龟后进入环内
此时，总有一时刻，兔子会与乌龟相遇
如果该链表无环，兔子会先走出该链表
题目 给定一个链表，判断链表中是否有环。
如果链表中有某个节点，可以通过连续跟踪 next 指针再次到达，则链表中存在环。 为了表示给定链表中的环，我们使用整数 pos 来表示链表尾连接到链表中的位置（索引从 0 开始）。 如果 pos 是 -1，则在该链表中没有环。注意：pos 不作为参数进行传递，仅仅是为了标识链表的实际情况。
如果链表中存在环，则返回 true 。 否则，返回 false 。
 进阶：
你能用 O(1)（即，常量）内存解决此问题吗？
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/linked-list-cycle 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
分析 上面介绍了龟兔赛跑算法，这里我们就来实际使用一下
我们定义两个指针，分别是快指针 fast 和慢指针 slow 作为 兔子 和 乌龟
让 slow 指向链表头部， fast 指向头部的下一节点（为什么?）
当 slow 不等于 fast 时
让 slow 指针前进一个节点（乌龟跑得慢）
fast 指针前进两个节点（兔子跑得快）
如果有一刻，slow 等于 fast 则链表有环</description></item><item><title>Leetcode 136 只出现一次的数字(位运算)</title><link>https://fzxiao.top/posts/leetcode-136/</link><pubDate>Sat, 14 Nov 2020 16:48:42 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-136/</guid><description>题目 给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。
说明：
你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？
示例 1:
输入: [2,2,1] 输出: 1 示例 2:
输入: [4,1,2,1,2] 输出: 4 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/single-number 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
分析 我们这次先给出题解，再解释
class Solution { public int singleNumber(int[] nums) { int t = 0; for (int num : nums) { t = t ^ num; } return t; } } 上述出现的符号 ^ 代表了 异或运算(XOR)
这个运算的特点是 同值取零 异值取一
有几个重要的法则
归零律： a ^ a = 0</description></item><item><title>Leetcode 543 二叉树的直径</title><link>https://fzxiao.top/posts/leetcode-543/</link><pubDate>Tue, 10 Nov 2020 09:40:11 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-543/</guid><description>题目 给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。 示例 : 给定二叉树 1 / \ 2 3 / \ 4 5 返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。 注意：两结点之间的路径长度是以它们之间边的数目表示。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/diameter-of-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
分析 题目给出 二叉树的直径 是 任意两个结点路径长度的最大值
原问题等价于 求二叉树 以任意结点所能得到的最大路径
路径长度 等于 该节点的左深度L 与 右深度R 的和 加一（加上当前根节点）
我们表示为 Dnode = L + R + 1
我们所求的答案就是 Dnode 的最大值
题解 首先，我们定义一个全局变量 ans 表示最终答案, 并将其初始化为1
最终答案为 ans - 1
class Solution{ int ans; public int diameterOfBinaryTree(TreeNode root) { ans = 1; return ans - 1; } } 然后我们定义一个新函数 depth 用于求出最大左右深度: L, R</description></item><item><title>Leetcode 617 合并二叉树</title><link>https://fzxiao.top/posts/leetcode-617/</link><pubDate>Sat, 07 Nov 2020 19:10:44 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-617/</guid><description>题目 给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。 你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。 示例 1: 输入: Tree 1 Tree 2 1 2 / \ / \ 3 2 1 3 / \ \ 5 4 7 输出: 合并后的树: 3 / \ 4 5 / \ \ 5 4 7 注意: 合并必须从两个树的根节点开始。 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/merge-two-binary-trees 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 只需要同时遍历两颗二叉树
让当前节点值相加即可
如果有一节点为 null 直接返回另一节点
当节点均为 null 时结束
下面上递归
题解 /** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public TreeNode mergeTrees(TreeNode t1, TreeNode t2) { if (t1 == null &amp;amp;&amp;amp; t2 == null) { return null; } if (t1 == null) { return t2; } else if (t2 == null) { return t1; } t1.</description></item><item><title>Leetcode 226 翻转二叉树</title><link>https://fzxiao.top/posts/leetcode-226/</link><pubDate>Thu, 05 Nov 2020 08:47:55 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-226/</guid><description>题目 翻转一棵二叉树。
示例：
输入：
4 / \ 2 7 / \ / \ 1 3 6 9 输出：
4 / \ 7 2 / \ / \ 9 6 3 1 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/invert-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 翻转一颗二叉树，那还不简单
只有做到
把每一个节点的左节点和右节点互换
就将二叉树翻转了
那么很容易想到用递归
题解 定义递归函数 invertTree(root)
作用是将 root 的 root.left 和 root.right 互换 并返回互换后的 root
结束条件是
if (root == null) return root; 互换就很简单了不解释
完整解答
public TreeNode invertTree(TreeNode root) { TreeNode result = root; if (root == null) { return result; } root.</description></item><item><title>Leetcode 104 二叉树的最大深度</title><link>https://fzxiao.top/posts/leetcode-104/</link><pubDate>Wed, 04 Nov 2020 10:43:58 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-104/</guid><description>题目 给定一个二叉树，找出其最大深度。
二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。
说明: 叶子节点是指没有子节点的节点。
示例： 给定二叉树 [3,9,20,null,null,15,7]，
3 / \ 9 20 / \ 15 7 返回它的最大深度 3 。
来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路 看见二叉树，我就写递归（
首先，我们要求的是二叉树的最大深度
这最大深度是怎么构成的呢
最大深度 = max{最大左深度，最大右深度} + 1
而计算左右深度的方法是相同的
那么就很容易的写出一个递归函数用于给出最大深度
题解 定义递归函数 search(TreeNode p) 给出的是节点 p 的最大深度
/** * Definition for a binary tree node. * public class TreeNode { * int val; * TreeNode left; * TreeNode right; * TreeNode(int x) { val = x; } * } */ class Solution { public int maxDepth(TreeNode root) { return search(root); } public int search(TreeNode p) { int val = 0; int ans = 0; if (p == null) { return 0; } val++; ans += Math.</description></item><item><title>Leetcode 101 对称二叉树</title><link>https://fzxiao.top/posts/leetcode-101/</link><pubDate>Tue, 03 Nov 2020 07:46:37 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-101/</guid><description>题目 给定一个二叉树，检查它是否是镜像对称的。
 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
1 / \ 2 2 / \ / \ 3 4 4 3  但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
1 / \ 2 2 \ \ 3 3 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/symmetric-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路分析 一个对称的二叉树具有以下几点性质
节点 p,q 的值相等（第一步即 root 节点自身比较，显然相等） 节点 p 左孩子与 节点 q 右孩子相等 节点 p 右孩子与 节点 q 左孩子相等 这里我们选用递归来写
public boolean check(TreeNode p, TreeNode q) { } 明确递归跳出的条件</description></item><item><title>Leetcode 70 爬楼梯</title><link>https://fzxiao.top/posts/leetcode-70/</link><pubDate>Sat, 31 Oct 2020 10:47:46 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-70/</guid><description>题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
示例 1：
输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2：
输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 思路分析 这是一道动态规划题
我们先确定 dp[i] 的含义
本题中，我们定义 dp[i] 为爬上第 i 阶楼梯的方法数目</description></item><item><title>Leetcode 53 最大子序和</title><link>https://fzxiao.top/posts/leetcode-53/</link><pubDate>Fri, 30 Oct 2020 10:46:00 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-53/</guid><description>题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例:
输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 思路 这是一道动态规划题目，按照一般步骤，我们需要定义 dp[i] 的意义
在这题中 dp[i] 被定义为 以nums[i]结尾的最大子序和
那么按照数学归纳法，假设我们已知 dp[i-1] 如何求 dp[i]
稍加分析，我们会发现，dp[i] 的值只有两种情况
dp[i] = dp[i-1] + nums[i] OR dp[i] = nums[i] 那么写出状态转移方程 dp[i] = max{dp[i-1] + nums[i], nums[i]}
最终答案就是 dp[0&amp;hellip;i] 中最大的一个值
我们利用遍历得出即可
题解 class Solution { public int maxSubArray(int[] nums) { int length = nums.length; int[] dp = new int[length]; dp[0] = nums[0]; for (int i=1; i&amp;lt;length; i++) { dp[i] = Math.</description></item><item><title>Leetcode 20 有效的括号</title><link>https://fzxiao.top/posts/leetcode-20/</link><pubDate>Thu, 29 Oct 2020 13:21:42 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-20/</guid><description>题目 给定一个只包括 &amp;lsquo;('，')'，'{'，'}'，'['，']&amp;rsquo; 的字符串，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。
示例 1:
输入: &amp;quot;()&amp;quot; 输出: true 示例 2:
输入: &amp;quot;()[]{}&amp;quot; 输出: true 示例 3:
输入: &amp;quot;(]&amp;quot; 输出: false 示例 4:
输入: &amp;quot;([)]&amp;quot; 输出: false 示例 5:
输入: &amp;quot;{[]}&amp;quot; 输出: true 思路 我们先分析一个有效的括号有什么特点
显然需要满足
同种类型括号配对 如 ( ) { } 括号闭合顺序一致 如 ([]) 而不是 (][) 通过分析以上几点我们得出
这个字符串的长度应该是 2 的倍数
显而易见，不是 2 的倍数的字符串里的括号一定不闭合
先出现的括号要在最后闭合</description></item><item><title>Leetcode 21 合成有序链表</title><link>https://fzxiao.top/posts/leetcode-21/</link><pubDate>Tue, 27 Oct 2020 20:09:54 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-21/</guid><description>题目 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：
输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4 思路 &amp;amp;&amp;amp; 题解 这里我马上想到的是遍历
根据所给条件
我们遍历两链表
例：
l1 = l1.Next 为了让新链表升序，我们需要比较当前节点数据的大小
将更小的节点拼接在新链表上
这里可以写出初步框架
不妨设定头结点为 headNode
结果链表为 result
func mergeTowLists(l1 *ListNode, l2 *ListNode) *ListNode { headNode := &amp;amp;ListNode{} result := headNode for l1 != nil &amp;amp;&amp;amp; l2 != nil { if l1.Val &amp;lt;= l2.Val { headNode.Next = &amp;amp;ListNode{Val:l1.Val} l1 = l1.Next } else { headNode.Next = &amp;amp;ListNode{Val:l2.Val} l2 = l2.Next } headNode = headNode.</description></item><item><title>Leetcode 54 螺旋矩阵 附 人生中的第一次面试：字节跳动</title><link>https://fzxiao.top/posts/leetcode-54/</link><pubDate>Tue, 20 Oct 2020 22:35:45 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-54/</guid><description>背景 身为一名大一的学生，却想着投实习简历玩，居然无意命中字节跳动
于是乎，亲爱的面试官一题螺旋矩阵，让尚未刷题学习的我，成功回家等通知
多说无意，好好学习，下面看题目
题目 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。
示例 1:
输入: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] 输出: [1,2,3,6,9,8,7,4,5] 分析 正在面试的我，一脸懵逼，无从下手，面试官提示我这是一道很简单(本题难度中等)的题目 最后写了一点点，时间到了（菜 我 菜
其实这个题目，只需要抓住矩阵的边界条件，就可以很明朗的解决
不妨设输入矩阵为 matrix
那么矩阵中的每一行下标 用 x 表示
该行中的的元素下标 用 y 表示
那么访问矩阵中的每一个元素即可表示为
element = matrix[x][y] 按照要求，我们需要螺旋的遍历这个矩阵
遍历方向是 右 =&amp;gt; 下 =&amp;gt; 上 =&amp;gt; 左
每次碰到边界，即转向
循环直至完成遍历
定义
矩阵的行数 rows</description></item><item><title>利用 Github Actions 和 Hugo 搭建自动化构建的静态博客</title><link>https://fzxiao.top/posts/build-blog-by-hugo/</link><pubDate>Sun, 11 Oct 2020 16:05:21 +0800</pubDate><guid>https://fzxiao.top/posts/build-blog-by-hugo/</guid><description>前言 既然刚折腾完 Hugo，蹭着记忆还清晰，梳理一下搭建过程吧
工具和网站介绍 Hugo:
号称是世界上最快静态网页构建框架(framework)
由 Go 编写而成，用于生成我们博客所需的静态页面
Git:
Git 是一个分散式版本控制软件
Github:
最大的同性交友网站 GitHub是通过Git进行版本控制的软件源代码托管服务平台
本教程利用的是 Github 提供的名为 Github Pages 的免费网站托管服务
教程正文 Step 0: 安装 Git 和 注册 Github 安装 Git:
打开 Git 页面，按照你的操作系统，下载安装程序，并安装
注册 Github:
打开 Github 填写屏幕右侧的表单，跟随步骤进行即可
Step 1: 安装 Hugo Windows 用户:
下载:
前往Releases页面，查找名称类似于 hugo_0.76.3_Windows-64bit.zip 的压缩包，下载解压即可
请自行确定使用 x64/x86 版本</description></item><item><title>Leetcode 27 移除元素</title><link>https://fzxiao.top/posts/leetcode-27/</link><pubDate>Sat, 10 Oct 2020 19:46:46 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-27/</guid><description>题目 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
解析 先来分享一下题目要求
通过 原地修改数组 移除所给值 元素顺序可改变 返回数组长度 注：其实数组也是会被判定的，因为传入的是数组的引用 第一解 func removeElement(nums []int, val int) int { for i:=0; i&amp;lt;len(nums); i++{ if nums[i] == val{ nums = append(nums[:i], nums[i+1:]...) } } return len(nums) } 第一次写下了这个解法，遍历数组，如果是需要移除的数，就移除，最后返回数组长度
毫无疑问，这是个错解
因为没有考虑移除元素后，指针i已经+1，导致漏过了中间的元素
第二解 func removeElement(nums []int, val int) int { j := 0 for i:=0; i&amp;lt;len(nums); i++{ if nums[i] !</description></item><item><title>Hello Hugo!</title><link>https://fzxiao.top/posts/hello_hugo/</link><pubDate>Sat, 10 Oct 2020 17:03:53 +0800</pubDate><guid>https://fzxiao.top/posts/hello_hugo/</guid><description>人活着就在于折腾
我总是把 blog 系统折腾来折腾去，经历了 Wp -&amp;gt; Hexo -&amp;gt; Jeklly -&amp;gt; Hugo
但是文章却没好好写几篇wwww，这次换到了 Hugo 应该折腾到头了吧
步入了大一，给自己一个从头开始吧（各种方面的）
于是乎，这里既是新家啦，技术，日常什么的，就往这里放了吧(不知道又能坚持多久)
总之
Do what you love and love what you do.
让我们共勉吧</description></item></channel></rss>