<!doctype html><html lang=en-us><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=description content="题目 编写一个程序，找到两个单链表相交的起始节点。
注意：
 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存  示例 1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。   来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 题解 一解 稍加分析，想到了两种方法
一是用 HashMap 边遍历边存节点，然后判断节点是否出现在 HashMap 中"><title>Leetcode 160 相交链表</title><link rel=canonical href=https://fzxiao.top/posts/leetcode-160/><link rel=stylesheet href=/scss/style.min.css><meta property="og:title" content="Leetcode 160 相交链表"><meta property="og:description" content="题目 编写一个程序，找到两个单链表相交的起始节点。
注意：
 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存  示例 1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。   来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 题解 一解 稍加分析，想到了两种方法
一是用 HashMap 边遍历边存节点，然后判断节点是否出现在 HashMap 中"><meta property="og:url" content="https://fzxiao.top/posts/leetcode-160/"><meta property="og:site_name" content="FZxiao 的大仓库"><meta property="og:type" content="article"><meta property="article:section" content="Posts"><meta property="article:published_time" content="2020-11-18T15:12:57+08:00"><meta property="article:modified_time" content="2020-11-18T15:12:57+08:00"><meta name=twitter:site content="FZxiao233"><meta name=twitter:title content="Leetcode 160 相交链表"><meta name=twitter:description content="题目 编写一个程序，找到两个单链表相交的起始节点。
注意：
 如果两个链表没有交点，返回 null. 在返回结果后，两个链表仍须保持原有的结构。 可假定整个链表结构中没有循环。 程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存  示例 1：
输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3 输出：Reference of the node with value = 8 输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。   来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 题解 一解 稍加分析，想到了两种方法
一是用 HashMap 边遍历边存节点，然后判断节点是否出现在 HashMap 中"></head><body class="article-page keep-sidebar"><div class="container flex on-phone--column align-items--flex-start extended"><aside class="sidebar left-sidebar sticky"><button class="hamburger hamburger--spin" type=button id=toggle-menu aria-label>
<span class=hamburger-box><span class=hamburger-inner></span></span></button><header class=site-info><figure class=site-avatar><img src=/img/avatar_hu5438825b9b6d1014226d20d231e650c2_473880_300x300_resize_q75_box.jpg width=300 height=300 class=site-logo loading=lazy alt=Avatar>
<span class=emoji>🍥</span></figure><h1 class=site-name><a href=https://fzxiao.top>FZxiao 的大仓库</a></h1><h2 class=site-description>FZxiao的博客</h2></header><ol class=menu id=main-menu><li><a href=https://fzxiao.top/><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-home" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><polyline points="5 12 3 12 12 3 21 12 19 12"/><path d="M5 12v7a2 2 0 002 2h10a2 2 0 002-2v-7"/><path d="M9 21v-6a2 2 0 012-2h2a2 2 0 012 2v6"/></svg><span>主页</span></a></li><li><a href=https://fzxiao.top/about-cn><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-user" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="7" r="4"/><path d="M6 21v-2a4 4 0 014-4h4a4 4 0 014 4v2"/></svg><span>关于</span></a></li><li><a href=https://fzxiao.top/archives><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-archive" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><rect x="3" y="4" width="18" height="4" rx="2"/><path d="M5 8v10a2 2 0 002 2h10a2 2 0 002-2V8"/><line x1="10" y1="12" x2="14" y2="12"/></svg><span>存档</span></a></li></ol></aside><main class="main full-width"><article class=main-article><header class=article-header><div class=article-details><h2 class=article-title><a href=https://fzxiao.top/posts/leetcode-160/>Leetcode 160 相交链表</a></h2><footer class=article-time><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-clock" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><polyline points="12 7 12 12 15 15"/></svg><time class=article-time--published>Nov 18, 2020</time></footer></div></header><section class=article-content><h2 id=题目>题目</h2><p>编写一个程序，找到两个单链表相交的起始节点。</p><p>注意：</p><ul><li>如果两个链表没有交点，返回 null.</li><li>在返回结果后，两个链表仍须保持原有的结构。</li><li>可假定整个链表结构中没有循环。</li><li>程序尽量满足 O(n) 时间复杂度，且仅用 O(1) 内存</li></ul><p>示例 1：</p><pre><code>输入：intersectVal = 8, listA = [4,1,8,4,5], listB = [5,0,1,8,4,5], skipA = 2, skipB = 3
输出：Reference of the node with value = 8
输入解释：相交节点的值为 8 （注意，如果两个链表相交则不能为 0）。从各自的表头开始算起，链表 A 为 [4,1,8,4,5]，链表 B 为 [5,0,1,8,4,5]。在 A 中，相交节点前有 2 个节点；在 B 中，相交节点前有 3 个节点。
</code></pre><blockquote><p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/intersection-of-two-linked-lists
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。</p></blockquote><h2 id=题解>题解</h2><h3 id=一解>一解</h3><p>稍加分析，想到了两种方法</p><p>一是用 HashMap 边遍历边存节点，然后判断节点是否出现在 HashMap 中</p><p>但是这显然违背了 O(1) 内存</p><p>二是类似 strStr 函数的实现</p><p>直接暴力遍历</p><p>但是这是 O(mn) 的时间复杂度</p><p>总之先 AC 吧，就用第二种写了</p><div class=highlight><pre class=chroma><code class=language-Java data-lang=Java><span class=cm>/**
</span><span class=cm> * Definition for singly-linked list.
</span><span class=cm> * public class ListNode {
</span><span class=cm> *     int val;
</span><span class=cm> *     ListNode next;
</span><span class=cm> *     ListNode(int x) {
</span><span class=cm> *         val = x;
</span><span class=cm> *         next = null;
</span><span class=cm> *     }
</span><span class=cm> * }
</span><span class=cm> */</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
    <span class=kd>public</span> <span class=n>ListNode</span> <span class=nf>getIntersectionNode</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>headA</span><span class=o>,</span> <span class=n>ListNode</span> <span class=n>headB</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span><span class=o>(</span><span class=n>headA</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>headB</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
            <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=k>for</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>p</span> <span class=o>=</span> <span class=n>headA</span><span class=o>;</span> <span class=n>p</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span> <span class=n>p</span> <span class=o>=</span> <span class=n>p</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>{</span>
            <span class=k>for</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>q</span> <span class=o>=</span> <span class=n>headB</span><span class=o>;</span> <span class=n>q</span> <span class=o>!=</span> <span class=kc>null</span><span class=o>;</span> <span class=n>q</span> <span class=o>=</span> <span class=n>q</span><span class=o>.</span><span class=na>next</span><span class=o>)</span> <span class=o>{</span>
                <span class=k>if</span> <span class=o>(</span><span class=n>p</span> <span class=o>==</span> <span class=n>q</span><span class=o>)</span> <span class=o>{</span>
                    <span class=k>return</span> <span class=n>p</span><span class=o>;</span>
                <span class=o>}</span>
            <span class=o>}</span>
        <span class=o>}</span>
        <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><p>AC 了，就是结果惨不忍睹</p><p><img src=/imgs/leetcode-160/0.png alt></p><h2 id=二解>二解</h2><p>本方法就是官方题解中的第三解 双指针法</p><p>基本思路我们用一个例子来说明</p><p>假定两个链表</p><pre><code>a = [1, 3, 5, 7, 9, 11]
b = [2, 4, 9, 11]
</code></pre><p>我们把这两个链表以不同顺序连在一起</p><pre><code>c = [1, 3, 5, 7, 9, 11, 2, 4, 9, 11]
d = [2, 4, 9, 11, 1, 3, 5, 7, 9, 11]
</code></pre><p>得到 c, d 两个链表</p><p>我们发现有几个特点</p><ul><li><p>链表长度一致（a + b = b + a）</p></li><li><p>尾端（交叉端一致）即 [9, 11] 这一段</p><p>因为链表是前部不一致，后部交叉到一起，所以无论以什么顺序连接，两链表的最尾端总是一样的</p></li></ul><p>那么本题就很简单了，以两个指针p, q同时遍历两个链表</p><p>指针到达尾部时，定位到另一链表的头部继续遍历</p><p>由于交叉端一致，总会有 p == q</p><p>此时，p/q 就是交叉的节点</p><div class=highlight><pre class=chroma><code class=language-Java data-lang=Java><span class=cm>/**
</span><span class=cm> * Definition for singly-linked list.
</span><span class=cm> * public class ListNode {
</span><span class=cm> *     int val;
</span><span class=cm> *     ListNode next;
</span><span class=cm> *     ListNode(int x) {
</span><span class=cm> *         val = x;
</span><span class=cm> *         next = null;
</span><span class=cm> *     }
</span><span class=cm> * }
</span><span class=cm> */</span>
<span class=kd>public</span> <span class=kd>class</span> <span class=nc>Solution</span> <span class=o>{</span>
    <span class=kd>public</span> <span class=n>ListNode</span> <span class=nf>getIntersectionNode</span><span class=o>(</span><span class=n>ListNode</span> <span class=n>headA</span><span class=o>,</span> <span class=n>ListNode</span> <span class=n>headB</span><span class=o>)</span> <span class=o>{</span>
        <span class=k>if</span><span class=o>(</span><span class=n>headA</span> <span class=o>==</span> <span class=kc>null</span> <span class=o>||</span> <span class=n>headB</span> <span class=o>==</span> <span class=kc>null</span><span class=o>)</span> <span class=o>{</span>
            <span class=k>return</span> <span class=kc>null</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=n>ListNode</span> <span class=n>p</span> <span class=o>=</span> <span class=n>headA</span><span class=o>;</span>
        <span class=n>ListNode</span> <span class=n>q</span> <span class=o>=</span> <span class=n>headB</span><span class=o>;</span>
        <span class=k>while</span><span class=o>(</span><span class=n>p</span> <span class=o>!=</span> <span class=n>q</span><span class=o>)</span> <span class=o>{</span>
            <span class=n>p</span> <span class=o>=</span> <span class=n>p</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>?</span> <span class=n>p</span><span class=o>.</span><span class=na>next</span><span class=o>:</span> <span class=n>headB</span><span class=o>;</span>
            <span class=n>q</span> <span class=o>=</span> <span class=n>q</span> <span class=o>!=</span> <span class=kc>null</span> <span class=o>?</span> <span class=n>q</span><span class=o>.</span><span class=na>next</span><span class=o>:</span> <span class=n>headA</span><span class=o>;</span>
        <span class=o>}</span>
        <span class=k>return</span> <span class=n>p</span><span class=o>;</span>
    <span class=o>}</span>
<span class=o>}</span>
</code></pre></div><p>有人就要问了，要是 p, q不是交叉的，岂不是会一直循环然后超时？</p><p>其实不会，我们看这个例子</p><pre><code>a = [1, 3, 4]
b = [2, 4, 5, 6]
</code></pre><p>每次执行 p, q 的值我们用下面的这个表格表示</p><table><thead><tr><th>p</th><th>q</th></tr></thead><tbody><tr><td>1</td><td>2</td></tr><tr><td>3</td><td>4</td></tr><tr><td>4</td><td>5</td></tr><tr><td>null</td><td>6</td></tr><tr><td>2</td><td>null</td></tr><tr><td>4</td><td>1</td></tr><tr><td>5</td><td>3</td></tr><tr><td>6</td><td>4</td></tr><tr><td>null</td><td>null</td></tr></tbody></table><p>因为移动步数总是一致的（a + b）则，最后一步会同时到达 null</p><p>此时跳出循环 s</p></section><footer class=article-footer><section class=article-copyright><svg xmlns="http://www.w3.org/2000/svg" class="icon icon-tabler icon-tabler-copyright" width="24" height="24" viewBox="0 0 24 24" stroke-width="2" stroke="currentcolor" fill="none" stroke-linecap="round" stroke-linejoin="round"><path stroke="none" d="M0 0h24v24H0z"/><circle cx="12" cy="12" r="9"/><path d="M14.5 9a3.5 4 0 100 6"/></svg><span>Licensed under CC BY-NC-SA 4.0</span></section></footer></article><footer class=site-footer><section class=copyright>&copy; 2020 FZxiao 的大仓库</section><section class=powerby>Built with <a href=https://gohugo.io/ target=_blank rel=noopener>Hugo</a><br>Theme <b><a href=https://github.com/CaiJimmy/hugo-theme-stack target=_blank rel=noopener data-version=1.0.5>Stack</a></b> designed by
<a href=https://jimmycai.com target=_blank rel=noopener>Jimmy</a></section></footer><div class=pswp tabindex=-1 role=dialog aria-hidden=true style=display:none><div class=pswp__bg></div><div class=pswp__scroll-wrap><div class=pswp__container><div class=pswp__item></div><div class=pswp__item></div><div class=pswp__item></div></div><div class="pswp__ui pswp__ui--hidden"><div class=pswp__top-bar><div class=pswp__counter></div><button class="pswp__button pswp__button--close" title="Close (Esc)"></button>
<button class="pswp__button pswp__button--share" title=Share></button>
<button class="pswp__button pswp__button--fs" title="Toggle fullscreen"></button>
<button class="pswp__button pswp__button--zoom" title="Zoom in/out"></button><div class=pswp__preloader><div class=pswp__preloader__icn><div class=pswp__preloader__cut><div class=pswp__preloader__donut></div></div></div></div></div><div class="pswp__share-modal pswp__share-modal--hidden pswp__single-tap"><div class=pswp__share-tooltip></div></div><button class="pswp__button pswp__button--arrow--left" title="Previous (arrow left)"></button>
<button class="pswp__button pswp__button--arrow--right" title="Next (arrow right)"></button><div class=pswp__caption><div class=pswp__caption__center></div></div></div></div></div></main></div><script src=https://cdn.jsdelivr.net/npm/node-vibrant@3.1.5/dist/vibrant.min.js integrity="sha256-5NovOZc4iwiAWTYIFiIM7DxKUXKWvpVEuMEPLzcm5/g=" crossorigin=anonymous></script><script type=text/javascript src=/ts/main.js defer></script><script>(function(){const customFont=document.createElement('link');customFont.href="https://fonts.googleapis.com/css2?family=Lato:wght@300;400;700&display=swap";customFont.type="text/css";customFont.rel="stylesheet";document.head.appendChild(customFont);}());</script><link rel=stylesheet href=/css/highlight/light.min.css media="(prefers-color-scheme: light)"><link rel=stylesheet href=/css/highlight/dark.min.css media="(prefers-color-scheme: dark)"></body></html>