<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Posts on FZxiao 的大仓库</title><link>https://fzxiao233.github.io/posts/</link><description>Recent content in Posts on FZxiao 的大仓库</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Tue, 03 Nov 2020 07:46:37 +0800</lastBuildDate><atom:link href="https://fzxiao233.github.io/posts/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 101 对称二叉树</title><link>https://fzxiao233.github.io/posts/leetcode-101/</link><pubDate>Tue, 03 Nov 2020 07:46:37 +0800</pubDate><guid>https://fzxiao233.github.io/posts/leetcode-101/</guid><description>题目 给定一个二叉树，检查它是否是镜像对称的。
 例如，二叉树 [1,2,2,3,4,4,3] 是对称的。
1 / \ 2 2 / \ / \ 3 4 4 3  但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:
1 / \ 2 2 \ \ 3 3 来源：力扣（LeetCode） 链接：https://leetcode-cn.com/problems/symmetric-tree 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
思路分析 一个对称的二叉树具有以下几点性质
节点 p,q 的值相等（第一步即 root 节点自身比较，显然相等） 节点 p 左孩子与 节点 q 右孩子相等 节点 p 右孩子与 节点 q 左孩子相等 这里我们选用递归来写
public boolean check(TreeNode p, TreeNode q) { } 明确递归跳出的条件</description></item><item><title>Leetcode 70 爬楼梯</title><link>https://fzxiao233.github.io/posts/leetcode-70/</link><pubDate>Sat, 31 Oct 2020 10:47:46 +0800</pubDate><guid>https://fzxiao233.github.io/posts/leetcode-70/</guid><description>题目 假设你正在爬楼梯。需要 n 阶你才能到达楼顶。
每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？
注意：给定 n 是一个正整数。
示例 1：
输入： 2 输出： 2 解释： 有两种方法可以爬到楼顶。 1. 1 阶 + 1 阶 2. 2 阶 示例 2：
输入： 3 输出： 3 解释： 有三种方法可以爬到楼顶。 1. 1 阶 + 1 阶 + 1 阶 2. 1 阶 + 2 阶 3. 2 阶 + 1 阶 思路分析 这是一道动态规划题
我们先确定 dp[i] 的含义
本题中，我们定义 dp[i] 为爬上第 i 阶楼梯的方法数目</description></item><item><title>Leetcode 53 最大子序和</title><link>https://fzxiao233.github.io/posts/leetcode-53/</link><pubDate>Fri, 30 Oct 2020 10:46:00 +0800</pubDate><guid>https://fzxiao233.github.io/posts/leetcode-53/</guid><description>题目 给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。
示例:
输入: [-2,1,-3,4,-1,2,1,-5,4] 输出: 6 解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。 思路 这是一道动态规划题目，按照一般步骤，我们需要定义 dp[i] 的意义
在这题中 dp[i] 被定义为 以nums[i]结尾的最大子序和
那么按照数学归纳法，假设我们已知 dp[i-1] 如何求 dp[i]
稍加分析，我们会发现，dp[i] 的值只有两种情况
dp[i] = dp[i-1] + nums[i] OR dp[i] = nums[i] 那么写出状态转移方程 dp[i] = max{dp[i-1] + nums[i], nums[i]}
最终答案就是 dp[0&amp;hellip;i] 中最大的一个值
我们利用遍历得出即可
题解 class Solution { public int maxSubArray(int[] nums) { int length = nums.length; int[] dp = new int[length]; dp[0] = nums[0]; for (int i=1; i&amp;lt;length; i++) { dp[i] = Math.</description></item><item><title>Leetcode 20 有效的括号</title><link>https://fzxiao233.github.io/posts/leetcode-20/</link><pubDate>Thu, 29 Oct 2020 13:21:42 +0800</pubDate><guid>https://fzxiao233.github.io/posts/leetcode-20/</guid><description>题目 给定一个只包括 &amp;lsquo;('，')'，'{'，'}'，'['，']&amp;rsquo; 的字符串，判断字符串是否有效。
有效字符串需满足：
左括号必须用相同类型的右括号闭合。
左括号必须以正确的顺序闭合。
注意空字符串可被认为是有效字符串。
示例 1:
输入: &amp;quot;()&amp;quot; 输出: true 示例 2:
输入: &amp;quot;()[]{}&amp;quot; 输出: true 示例 3:
输入: &amp;quot;(]&amp;quot; 输出: false 示例 4:
输入: &amp;quot;([)]&amp;quot; 输出: false 示例 5:
输入: &amp;quot;{[]}&amp;quot; 输出: true 思路 我们先分析一个有效的括号有什么特点
显然需要满足
同种类型括号配对 如 ( ) { } 括号闭合顺序一致 如 ([]) 而不是 (][) 通过分析以上几点我们得出
这个字符串的长度应该是 2 的倍数
显而易见，不是 2 的倍数的字符串里的括号一定不闭合
先出现的括号要在最后闭合</description></item><item><title>Leetcode 21 合成有序链表</title><link>https://fzxiao233.github.io/posts/leetcode-21/</link><pubDate>Tue, 27 Oct 2020 20:09:54 +0800</pubDate><guid>https://fzxiao233.github.io/posts/leetcode-21/</guid><description>题目 将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 示例：
输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4 输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4 思路 &amp;amp;&amp;amp; 题解 这里我马上想到的是遍历
根据所给条件
我们遍历两链表
例：
l1 = l1.Next 为了让新链表升序，我们需要比较当前节点数据的大小
将更小的节点拼接在新链表上
这里可以写出初步框架
不妨设定头结点为 headNode
结果链表为 result
func mergeTowLists(l1 *ListNode, l2 *ListNode) *ListNode { headNode := &amp;amp;ListNode{} result := headNode for l1 != nil &amp;amp;&amp;amp; l2 != nil { if l1.Val &amp;lt;= l2.Val { headNode.Next = &amp;amp;ListNode{Val:l1.Val} l1 = l1.Next } else { headNode.Next = &amp;amp;ListNode{Val:l2.Val} l2 = l2.Next } headNode = headNode.</description></item><item><title>Leetcode 54 螺旋矩阵 附 人生中的第一次面试：字节跳动</title><link>https://fzxiao233.github.io/posts/leetcode-54/</link><pubDate>Tue, 20 Oct 2020 22:35:45 +0800</pubDate><guid>https://fzxiao233.github.io/posts/leetcode-54/</guid><description>背景 身为一名大一的学生，却想着投实习简历玩，居然无意命中字节跳动
于是乎，亲爱的面试官一题螺旋矩阵，让尚未刷题学习的我，成功回家等通知
多说无意，好好学习，下面看题目
题目 给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。
示例 1:
输入: [ [ 1, 2, 3 ], [ 4, 5, 6 ], [ 7, 8, 9 ] ] 输出: [1,2,3,6,9,8,7,4,5] 分析 正在面试的我，一脸懵逼，无从下手，面试官提示我这是一道很简单(本题难度中等)的题目 最后写了一点点，时间到了（菜 我 菜
其实这个题目，只需要抓住矩阵的边界条件，就可以很明朗的解决
不妨设输入矩阵为 matrix
那么矩阵中的每一行下标 用 x 表示
该行中的的元素下标 用 y 表示
那么访问矩阵中的每一个元素即可表示为
element = matrix[x][y] 按照要求，我们需要螺旋的遍历这个矩阵
遍历方向是 右 =&amp;gt; 下 =&amp;gt; 上 =&amp;gt; 左
每次碰到边界，即转向
循环直至完成遍历
定义
矩阵的行数 rows</description></item><item><title>利用 Github Actions 和 Hugo 搭建自动化构建的静态博客</title><link>https://fzxiao233.github.io/posts/build-blog-by-hugo/</link><pubDate>Sun, 11 Oct 2020 16:05:21 +0800</pubDate><guid>https://fzxiao233.github.io/posts/build-blog-by-hugo/</guid><description>前言 既然刚折腾完 Hugo，蹭着记忆还清晰，梳理一下搭建过程吧
工具和网站介绍 Hugo:
号称是世界上最快静态网页构建框架(framework)
由 Go 编写而成，用于生成我们博客所需的静态页面
Git:
Git 是一个分散式版本控制软件
Github:
最大的同性交友网站 GitHub是通过Git进行版本控制的软件源代码托管服务平台
本教程利用的是 Github 提供的名为 Github Pages 的免费网站托管服务
教程正文 Step 0: 安装 Git 和 注册 Github 安装 Git:
打开 Git 页面，按照你的操作系统，下载安装程序，并安装
注册 Github:
打开 Github 填写屏幕右侧的表单，跟随步骤进行即可
Step 1: 安装 Hugo Windows 用户:
下载:
前往Releases页面，查找名称类似于 hugo_0.76.3_Windows-64bit.zip 的压缩包，下载解压即可
请自行确定使用 x64/x86 版本</description></item><item><title>Leetcode 27 移除元素</title><link>https://fzxiao233.github.io/posts/leetcode-27/</link><pubDate>Sat, 10 Oct 2020 19:46:46 +0800</pubDate><guid>https://fzxiao233.github.io/posts/leetcode-27/</guid><description>题目 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。
元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。
解析 先来分享一下题目要求
通过 原地修改数组 移除所给值 元素顺序可改变 返回数组长度 注：其实数组也是会被判定的，因为传入的是数组的引用 第一解 func removeElement(nums []int, val int) int { for i:=0; i&amp;lt;len(nums); i++{ if nums[i] == val{ nums = append(nums[:i], nums[i+1:]...) } } return len(nums) } 第一次写下了这个解法，遍历数组，如果是需要移除的数，就移除，最后返回数组长度
毫无疑问，这是个错解
因为没有考虑移除元素后，指针i已经+1，导致漏过了中间的元素
第二解 func removeElement(nums []int, val int) int { j := 0 for i:=0; i&amp;lt;len(nums); i++{ if nums[i] !</description></item><item><title>Hello Hugo!</title><link>https://fzxiao233.github.io/posts/hello_hugo/</link><pubDate>Sat, 10 Oct 2020 17:03:53 +0800</pubDate><guid>https://fzxiao233.github.io/posts/hello_hugo/</guid><description>人活着就在于折腾
我总是把 blog 系统折腾来折腾去，经历了 Wp -&amp;gt; Hexo -&amp;gt; Jeklly -&amp;gt; Hugo
但是文章却没好好写几篇wwww，这次换到了 Hugo 应该折腾到头了吧
步入了大一，给自己一个从头开始吧（各种方面的）
于是乎，这里既是新家啦，技术，日常什么的，就往这里放了吧(不知道又能坚持多久)
总之
Do what you love and love what you do.
让我们共勉吧</description></item></channel></rss>