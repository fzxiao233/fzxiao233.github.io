<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>FZxiao 的大仓库</title><link>https://fzxiao.top/</link><description>Recent content on FZxiao 的大仓库</description><generator>Hugo -- gohugo.io</generator><language>en-us</language><lastBuildDate>Sat, 14 Nov 2020 16:48:42 +0800</lastBuildDate><atom:link href="https://fzxiao.top/index.xml" rel="self" type="application/rss+xml"/><item><title>Leetcode 136 只出现一次的数字(位运算)</title><link>https://fzxiao.top/posts/leetcode-136/</link><pubDate>Sat, 14 Nov 2020 16:48:42 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-136/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给定一个非空整数数组，除了某个元素只出现一次以外，其余每个元素均出现两次。找出那个只出现了一次的元素。&lt;/p>
&lt;p>说明：&lt;/p>
&lt;p>你的算法应该具有线性时间复杂度。 你可以不使用额外空间来实现吗？&lt;/p>
&lt;p>示例 1:&lt;/p>
&lt;pre>&lt;code>输入: [2,2,1]
输出: 1
&lt;/code>&lt;/pre>
&lt;p>示例 2:&lt;/p>
&lt;pre>&lt;code>输入: [4,1,2,1,2]
输出: 4
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/single-number
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;/blockquote>
&lt;h2 id="分析">分析&lt;/h2>
&lt;p>我们这次先给出题解，再解释&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="kd">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">singleNumber&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">num&lt;/span> &lt;span class="o">:&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">t&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">t&lt;/span> &lt;span class="o">^&lt;/span> &lt;span class="n">num&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">t&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>上述出现的符号 ^ 代表了 异或运算(XOR)&lt;/p>
&lt;p>这个运算的特点是 同值取零 异值取一&lt;/p>
&lt;p>有几个重要的法则&lt;/p>
&lt;ol>
&lt;li>
&lt;p>归零律： a ^ a = 0&lt;/p>
&lt;/li>
&lt;li>
&lt;p>恒等律： a ^ 0 = a&lt;/p>
&lt;/li>
&lt;li>
&lt;p>交换律： a ^ b ^ c = a ^ c ^ b&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>那么就很好解释了&lt;/p>
&lt;p>我们从数组 nums 中取出一个 num 与 t 计算的值再赋给 t&lt;/p>
&lt;p>例如对于数组[2, 2, 1]&lt;/p>
&lt;table>
&lt;thead>
&lt;tr>
&lt;th>t&lt;/th>
&lt;th>num&lt;/th>
&lt;/tr>
&lt;/thead>
&lt;tbody>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>2&lt;/td>
&lt;td>2&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>0&lt;/td>
&lt;td>1&lt;/td>
&lt;/tr>
&lt;tr>
&lt;td>1&lt;/td>
&lt;td>/&lt;/td>
&lt;/tr>
&lt;/tbody>
&lt;/table>
&lt;p>相同数字异或全归为0&lt;/p>
&lt;p>剩下 0 与 唯一数异或得到该数字&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>位运算是一类很特别的题目，要多加反复练习&lt;/p></description></item><item><title>Leetcode 543 二叉树的直径</title><link>https://fzxiao.top/posts/leetcode-543/</link><pubDate>Tue, 10 Nov 2020 09:40:11 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-543/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;pre>&lt;code>给定一棵二叉树，你需要计算它的直径长度。一棵二叉树的直径长度是任意两个结点路径长度中的最大值。这条路径可能穿过也可能不穿过根结点。
 
示例 :
给定二叉树
1
/ \
2 3
/ \
4 5
返回 3, 它的长度是路径 [4,2,1,3] 或者 [5,2,1,3]。
 
注意：两结点之间的路径长度是以它们之间边的数目表示。
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/diameter-of-binary-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;/blockquote>
&lt;h2 id="分析">分析&lt;/h2>
&lt;p>题目给出 二叉树的直径 是 任意两个结点路径长度的最大值&lt;/p>
&lt;p>原问题等价于 求二叉树 以任意结点所能得到的最大路径&lt;/p>
&lt;p>路径长度 等于 该节点的左深度L 与 右深度R 的和 加一（加上当前根节点）&lt;/p>
&lt;p>我们表示为 Dnode = L + R + 1&lt;/p>
&lt;p>我们所求的答案就是 Dnode 的最大值&lt;/p>
&lt;h2 id="题解">题解&lt;/h2>
&lt;p>首先，我们定义一个全局变量 ans 表示最终答案, 并将其初始化为1&lt;/p>
&lt;p>最终答案为 ans - 1&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="kd">class&lt;/span> &lt;span class="nc">Solution&lt;/span>&lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">ans&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">diameterOfBinaryTree&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">ans&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">ans&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后我们定义一个新函数 depth 用于求出最大左右深度: L, R&lt;/p>
&lt;p>同时更新 ans 的结果&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Java" data-lang="Java"> &lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">depth&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">L&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">depth&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">R&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">depth&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">ans&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">max&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ans&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">L&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">R&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">max&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">L&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">R&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>在原函数上加上调用即可&lt;/p>
&lt;p>全解如下:&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * Definition for a binary tree node.
&lt;/span>&lt;span class="cm"> * public class TreeNode {
&lt;/span>&lt;span class="cm"> * int val;
&lt;/span>&lt;span class="cm"> * TreeNode left;
&lt;/span>&lt;span class="cm"> * TreeNode right;
&lt;/span>&lt;span class="cm"> * TreeNode(int x) { val = x; }
&lt;/span>&lt;span class="cm"> * }
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">ans&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">diameterOfBinaryTree&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">ans&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">depth&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">ans&lt;/span> &lt;span class="o">-&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">depth&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">L&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">R&lt;/span> &lt;span class="o">=&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">L&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">depth&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">R&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">depth&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">ans&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">max&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">ans&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">L&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">R&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">max&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">L&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">R&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>本题需要注意条件的转换&lt;/p>
&lt;p>求最大值问题可以通过不断更新所求值来实现&lt;/p></description></item><item><title>Leetcode 617 合并二叉树</title><link>https://fzxiao.top/posts/leetcode-617/</link><pubDate>Sat, 07 Nov 2020 19:10:44 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-617/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;pre>&lt;code>给定两个二叉树，想象当你将它们中的一个覆盖到另一个上时，两个二叉树的一些节点便会重叠。
你需要将他们合并为一个新的二叉树。合并的规则是如果两个节点重叠，那么将他们的值相加作为节点合并后的新值，否则不为 NULL 的节点将直接作为新二叉树的节点。
示例 1:
输入:
Tree 1 Tree 2
1 2
/ \ / \
3 2 1 3
/ \ \
5 4 7
输出:
合并后的树:
3
/ \
4 5
/ \ \
5 4 7
注意: 合并必须从两个树的根节点开始。
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/merge-two-binary-trees
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;/blockquote>
&lt;h2 id="思路">思路&lt;/h2>
&lt;p>只需要同时遍历两颗二叉树&lt;/p>
&lt;p>让当前节点值相加即可&lt;/p>
&lt;p>如果有一节点为 null 直接返回另一节点&lt;/p>
&lt;p>当节点均为 null 时结束&lt;/p>
&lt;p>下面上递归&lt;/p>
&lt;h2 id="题解">题解&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * Definition for a binary tree node.
&lt;/span>&lt;span class="cm"> * public class TreeNode {
&lt;/span>&lt;span class="cm"> * int val;
&lt;/span>&lt;span class="cm"> * TreeNode left;
&lt;/span>&lt;span class="cm"> * TreeNode right;
&lt;/span>&lt;span class="cm"> * TreeNode(int x) { val = x; }
&lt;/span>&lt;span class="cm"> * }
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="n">TreeNode&lt;/span> &lt;span class="nf">mergeTrees&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">t1&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">TreeNode&lt;/span> &lt;span class="n">t2&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">t1&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">t2&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">t1&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">t2&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">t2&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">t1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">t1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">t2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">t1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mergeTrees&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">t2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">t1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">mergeTrees&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">t1&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">t2&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">t1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>没啥好总结的耶，二叉树就是大致这么个框架&lt;/p>
&lt;p>递归 进行一点点操作 结束&lt;/p></description></item><item><title>Leetcode 226 翻转二叉树</title><link>https://fzxiao.top/posts/leetcode-226/</link><pubDate>Thu, 05 Nov 2020 08:47:55 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-226/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>翻转一棵二叉树。&lt;/p>
&lt;p>示例：&lt;/p>
&lt;p>输入：&lt;/p>
&lt;pre>&lt;code> 4
/ \
2 7
/ \ / \
1 3 6 9
&lt;/code>&lt;/pre>
&lt;p>输出：&lt;/p>
&lt;pre>&lt;code> 4
/ \
7 2
/ \ / \
9 6 3 1
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/invert-binary-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;/blockquote>
&lt;h2 id="思路">思路&lt;/h2>
&lt;p>翻转一颗二叉树，那还不简单&lt;/p>
&lt;p>只有做到&lt;/p>
&lt;p>把每一个节点的左节点和右节点互换&lt;/p>
&lt;p>就将二叉树翻转了&lt;/p>
&lt;p>那么很容易想到用递归&lt;/p>
&lt;h2 id="题解">题解&lt;/h2>
&lt;p>定义递归函数 invertTree(root)&lt;/p>
&lt;p>作用是将 root 的 root.left 和 root.right 互换 并返回互换后的 root&lt;/p>
&lt;p>结束条件是&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">;&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>互换就很简单了不解释&lt;/p>
&lt;p>完整解答&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="kd">public&lt;/span> &lt;span class="n">TreeNode&lt;/span> &lt;span class="nf">invertTree&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">invertTree&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">invertTree&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">temp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">temp&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>好像没有什么好总结的哦，因为被我一遍过了(&lt;/p></description></item><item><title>Leetcode 104 二叉树的最大深度</title><link>https://fzxiao.top/posts/leetcode-104/</link><pubDate>Wed, 04 Nov 2020 10:43:58 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-104/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给定一个二叉树，找出其最大深度。&lt;/p>
&lt;p>二叉树的深度为根节点到最远叶子节点的最长路径上的节点数。&lt;/p>
&lt;p>说明: 叶子节点是指没有子节点的节点。&lt;/p>
&lt;p>示例：
给定二叉树 [3,9,20,null,null,15,7]，&lt;/p>
&lt;pre>&lt;code> 3
/ \
9 20
/ \
15 7
&lt;/code>&lt;/pre>
&lt;p>返回它的最大深度 3 。&lt;/p>
&lt;blockquote>
&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/maximum-depth-of-binary-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;/blockquote>
&lt;h2 id="思路">思路&lt;/h2>
&lt;p>看见二叉树，我就写递归（&lt;/p>
&lt;p>首先，我们要求的是二叉树的最大深度&lt;/p>
&lt;p>这最大深度是怎么构成的呢&lt;/p>
&lt;p>最大深度 = max{最大左深度，最大右深度} + 1&lt;/p>
&lt;p>而计算左右深度的方法是相同的&lt;/p>
&lt;p>那么就很容易的写出一个递归函数用于给出最大深度&lt;/p>
&lt;h2 id="题解">题解&lt;/h2>
&lt;p>定义递归函数 search(TreeNode p) 给出的是节点 p 的最大深度&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * Definition for a binary tree node.
&lt;/span>&lt;span class="cm"> * public class TreeNode {
&lt;/span>&lt;span class="cm"> * int val;
&lt;/span>&lt;span class="cm"> * TreeNode left;
&lt;/span>&lt;span class="cm"> * TreeNode right;
&lt;/span>&lt;span class="cm"> * TreeNode(int x) { val = x; }
&lt;/span>&lt;span class="cm"> * }
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">maxDepth&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">search&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">search&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">val&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">ans&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">val&lt;/span>&lt;span class="o">++;&lt;/span>
&lt;span class="n">ans&lt;/span> &lt;span class="o">+=&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">max&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">val&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">search&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">),&lt;/span> &lt;span class="n">val&lt;/span> &lt;span class="o">+&lt;/span>&lt;span class="n">search&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">));&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">ans&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>细细一想写了很多废话&lt;/p>
&lt;p>二稿&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * Definition for a binary tree node.
&lt;/span>&lt;span class="cm"> * public class TreeNode {
&lt;/span>&lt;span class="cm"> * int val;
&lt;/span>&lt;span class="cm"> * TreeNode left;
&lt;/span>&lt;span class="cm"> * TreeNode right;
&lt;/span>&lt;span class="cm"> * TreeNode(int x) { val = x; }
&lt;/span>&lt;span class="cm"> * }
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">maxDepth&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">max&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">maxDepth&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">),&lt;/span> &lt;span class="n">maxDepth&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">))&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>二叉树我就是递归，明确递归函数的定义即可秒杀&lt;/p></description></item><item><title>Leetcode 101 对称二叉树</title><link>https://fzxiao.top/posts/leetcode-101/</link><pubDate>Tue, 03 Nov 2020 07:46:37 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-101/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给定一个二叉树，检查它是否是镜像对称的。&lt;/p>
&lt;p> &lt;/p>
&lt;p>例如，二叉树 [1,2,2,3,4,4,3] 是对称的。&lt;/p>
&lt;pre>&lt;code> 1
/ \
2 2
/ \ / \
3 4 4 3
&lt;/code>&lt;/pre>
&lt;p> &lt;/p>
&lt;p>但是下面这个 [1,2,2,null,3,null,3] 则不是镜像对称的:&lt;/p>
&lt;pre>&lt;code> 1
/ \
2 2
\ \
3 3
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>来源：力扣（LeetCode）
链接：https://leetcode-cn.com/problems/symmetric-tree
著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。&lt;/p>
&lt;/blockquote>
&lt;h2 id="思路分析">思路分析&lt;/h2>
&lt;p>一个对称的二叉树具有以下几点性质&lt;/p>
&lt;ol>
&lt;li>节点 p,q 的值相等（第一步即 root 节点自身比较，显然相等）&lt;/li>
&lt;li>节点 p 左孩子与 节点 q 右孩子相等&lt;/li>
&lt;li>节点 p 右孩子与 节点 q 左孩子相等&lt;/li>
&lt;/ol>
&lt;p>这里我们选用递归来写&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">check&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">TreeNode&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>明确递归跳出的条件&lt;/p>
&lt;ol>
&lt;li>
&lt;p>节点均为 null 时返回 true&lt;/p>
&lt;p>此时该节点显然对称&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">q&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>节点仅有一个为 null 时返回 false&lt;/p>
&lt;p>显然此时不对称&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">q&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;li>
&lt;p>当前节点的值相等，且满足对称二叉树的 2，3 条性质&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="k">return&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">check&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">check&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">);&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;/li>
&lt;/ol>
&lt;p>下面看完整题解&lt;/p>
&lt;h2 id="题解">题解&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * Definition for a binary tree node.
&lt;/span>&lt;span class="cm"> * public class TreeNode {
&lt;/span>&lt;span class="cm"> * int val;
&lt;/span>&lt;span class="cm"> * TreeNode left;
&lt;/span>&lt;span class="cm"> * TreeNode right;
&lt;/span>&lt;span class="cm"> * TreeNode(int x) { val = x; }
&lt;/span>&lt;span class="cm"> * }
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isSymmetric&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">check&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">check&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">TreeNode&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">q&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">q&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">p&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">check&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">check&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">p&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">q&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>这个题目摆明了就是让你递归，只要明确了二叉树对称的性质，即可轻松解题&lt;/p>
&lt;p>能用递归解决的问题，大部分也能用含有辅助栈的迭代解决&lt;/p>
&lt;h2 id="迭代解法">迭代解法&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="cm">/**
&lt;/span>&lt;span class="cm"> * Definition for a binary tree node.
&lt;/span>&lt;span class="cm"> * public class TreeNode {
&lt;/span>&lt;span class="cm"> * int val;
&lt;/span>&lt;span class="cm"> * TreeNode left;
&lt;/span>&lt;span class="cm"> * TreeNode right;
&lt;/span>&lt;span class="cm"> * TreeNode(int x) { val = x; }
&lt;/span>&lt;span class="cm"> * }
&lt;/span>&lt;span class="cm"> */&lt;/span>
&lt;span class="kd">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">isSymmetric&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">check&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">root&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">root&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">boolean&lt;/span> &lt;span class="nf">check&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">TreeNode&lt;/span> &lt;span class="n">u&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">TreeNode&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">Queue&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">TreeNode&lt;/span>&lt;span class="o">&amp;gt;&lt;/span> &lt;span class="n">queue&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="n">LinkedList&lt;/span>&lt;span class="o">&amp;lt;&amp;gt;();&lt;/span>
&lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">offer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">offer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="k">while&lt;/span>&lt;span class="o">(!&lt;/span>&lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">isEmpty&lt;/span>&lt;span class="o">())&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">u&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">poll&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="n">v&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">poll&lt;/span>&lt;span class="o">();&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">u&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">continue&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="n">u&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">v&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">null&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="n">u&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="n">v&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">val&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">offer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">offer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">offer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">u&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">right&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="n">queue&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">offer&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">v&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">left&lt;/span>&lt;span class="o">);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">true&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>其实本质和递归是一样的，因为递归其实自带了函数栈&lt;/p>
&lt;p>我们每次判断后将一对子节点压入栈中&lt;/p>
&lt;p>迭代的取出并判断&lt;/p>
&lt;p>最终栈元素为零时，改二叉树就对称&lt;/p>
&lt;p>否则就会在判断过程中被提前返回&lt;/p></description></item><item><title>Leetcode 70 爬楼梯</title><link>https://fzxiao.top/posts/leetcode-70/</link><pubDate>Sat, 31 Oct 2020 10:47:46 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-70/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>假设你正在爬楼梯。需要 n 阶你才能到达楼顶。&lt;/p>
&lt;p>每次你可以爬 1 或 2 个台阶。你有多少种不同的方法可以爬到楼顶呢？&lt;/p>
&lt;p>注意：给定 n 是一个正整数。&lt;/p>
&lt;p>示例 1：&lt;/p>
&lt;pre>&lt;code>输入： 2
输出： 2
解释： 有两种方法可以爬到楼顶。
1. 1 阶 + 1 阶
2. 2 阶
&lt;/code>&lt;/pre>
&lt;p>示例 2：&lt;/p>
&lt;pre>&lt;code>输入： 3
输出： 3
解释： 有三种方法可以爬到楼顶。
1. 1 阶 + 1 阶 + 1 阶
2. 1 阶 + 2 阶
3. 2 阶 + 1 阶
&lt;/code>&lt;/pre>
&lt;h2 id="思路分析">思路分析&lt;/h2>
&lt;p>这是一道动态规划题&lt;/p>
&lt;p>我们先确定 dp[i] 的含义&lt;/p>
&lt;p>本题中，我们定义 dp[i] 为爬上第 i 阶楼梯的方法数目&lt;/p>
&lt;p>根据题意，爬上每一阶楼梯有两种方法&lt;/p>
&lt;p>即从 i-1 阶 或 i-2 阶爬上&lt;/p>
&lt;p>那么写出状态转移方程&lt;/p>
&lt;pre>&lt;code>dp[i] = dp[i-1] + dp[i-2]
&lt;/code>&lt;/pre>
&lt;p>还需注意边界条件&lt;/p>
&lt;p>爬上第 1 阶的时候，显然只有一种方法&lt;/p>
&lt;pre>&lt;code>dp[1] = 1
&lt;/code>&lt;/pre>
&lt;p>爬上第 2 阶的时候&lt;/p>
&lt;pre>&lt;code>dp[2] = dp[1] + dp[0]
&lt;/code>&lt;/pre>
&lt;p>那么显然爬上第二阶有两种方法，这样我们确定了&lt;/p>
&lt;pre>&lt;code>dp[0] = 1
&lt;/code>&lt;/pre>
&lt;p>最后答案就是 dp[n]&lt;/p>
&lt;h2 id="题解">题解&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="kd">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">climbStairs&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">n&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">dp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">dp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="n">dp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">for&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">dp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">dp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">dp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">2&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">dp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">n&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>emmmm，我突然意识到，这好像是斐波那契数列&lt;/p>
&lt;p>总之用动态规划写了&lt;/p></description></item><item><title>Leetcode 53 最大子序和</title><link>https://fzxiao.top/posts/leetcode-53/</link><pubDate>Fri, 30 Oct 2020 10:46:00 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-53/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给定一个整数数组 nums ，找到一个具有最大和的连续子数组（子数组最少包含一个元素），返回其最大和。&lt;/p>
&lt;p>示例:&lt;/p>
&lt;pre>&lt;code>输入: [-2,1,-3,4,-1,2,1,-5,4]
输出: 6
解释: 连续子数组 [4,-1,2,1] 的和最大，为 6。
&lt;/code>&lt;/pre>
&lt;h2 id="思路">思路&lt;/h2>
&lt;p>这是一道动态规划题目，按照一般步骤，我们需要定义 dp[i] 的意义&lt;/p>
&lt;p>在这题中 dp[i] 被定义为 以nums[i]结尾的最大子序和&lt;/p>
&lt;p>那么按照数学归纳法，假设我们已知 dp[i-1] 如何求 dp[i]&lt;/p>
&lt;p>稍加分析，我们会发现，dp[i] 的值只有两种情况&lt;/p>
&lt;pre>&lt;code>dp[i] = dp[i-1] + nums[i]
OR
dp[i] = nums[i]
&lt;/code>&lt;/pre>
&lt;p>那么写出状态转移方程 dp[i] = max{dp[i-1] + nums[i], nums[i]}&lt;/p>
&lt;p>最终答案就是 dp[0&amp;hellip;i] 中最大的一个值&lt;/p>
&lt;p>我们利用遍历得出即可&lt;/p>
&lt;h2 id="题解">题解&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Java" data-lang="Java">&lt;span class="kd">class&lt;/span> &lt;span class="nc">Solution&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kd">public&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="nf">maxSubArray&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">length&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">length&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="kt">int&lt;/span>&lt;span class="o">[]&lt;/span> &lt;span class="n">dp&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="k">new&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="n">dp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">];&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">dp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">max&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">],&lt;/span> &lt;span class="n">dp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="n">1&lt;/span>&lt;span class="o">]&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="n">nums&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="kt">int&lt;/span> &lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Integer&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">MIN_VALUE&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="o">(&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">=&lt;/span>&lt;span class="n">0&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">&amp;lt;&lt;/span>&lt;span class="n">length&lt;/span>&lt;span class="o">;&lt;/span> &lt;span class="n">i&lt;/span>&lt;span class="o">++)&lt;/span> &lt;span class="o">{&lt;/span>
&lt;span class="n">result&lt;/span> &lt;span class="o">=&lt;/span> &lt;span class="n">Math&lt;/span>&lt;span class="o">.&lt;/span>&lt;span class="na">max&lt;/span>&lt;span class="o">(&lt;/span>&lt;span class="n">result&lt;/span>&lt;span class="o">,&lt;/span> &lt;span class="n">dp&lt;/span>&lt;span class="o">[&lt;/span>&lt;span class="n">i&lt;/span>&lt;span class="o">]);&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="n">result&lt;/span>&lt;span class="o">;&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;span class="o">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>这是一题比较特别的动态规划，与其他题目对 dp[i] 的定义有所不同&lt;/p>
&lt;p>但只需实际分析 dp[i] 会出现的两种结果，即可得出答案&lt;/p></description></item><item><title>Leetcode 20 有效的括号</title><link>https://fzxiao.top/posts/leetcode-20/</link><pubDate>Thu, 29 Oct 2020 13:21:42 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-20/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给定一个只包括 &amp;lsquo;('，')'，'{'，'}'，'['，']&amp;rsquo; 的字符串，判断字符串是否有效。&lt;/p>
&lt;p>有效字符串需满足：&lt;/p>
&lt;p>左括号必须用相同类型的右括号闭合。&lt;/p>
&lt;p>左括号必须以正确的顺序闭合。&lt;/p>
&lt;p>注意空字符串可被认为是有效字符串。&lt;/p>
&lt;p>示例 1:&lt;/p>
&lt;pre>&lt;code>输入: &amp;quot;()&amp;quot;
输出: true
&lt;/code>&lt;/pre>
&lt;p>示例 2:&lt;/p>
&lt;pre>&lt;code>输入: &amp;quot;()[]{}&amp;quot;
输出: true
&lt;/code>&lt;/pre>
&lt;p>示例 3:&lt;/p>
&lt;pre>&lt;code>输入: &amp;quot;(]&amp;quot;
输出: false
&lt;/code>&lt;/pre>
&lt;p>示例 4:&lt;/p>
&lt;pre>&lt;code>输入: &amp;quot;([)]&amp;quot;
输出: false
&lt;/code>&lt;/pre>
&lt;p>示例 5:&lt;/p>
&lt;pre>&lt;code>输入: &amp;quot;{[]}&amp;quot;
输出: true
&lt;/code>&lt;/pre>
&lt;h2 id="思路">思路&lt;/h2>
&lt;p>我们先分析一个有效的括号有什么特点&lt;/p>
&lt;p>显然需要满足&lt;/p>
&lt;ol>
&lt;li>同种类型括号配对 如 ( ) { } &lt;input disabled="" type="checkbox"> &lt;/li>
&lt;li>括号闭合顺序一致 如 ([]) 而不是 (][)&lt;/li>
&lt;/ol>
&lt;p>通过分析以上几点我们得出&lt;/p>
&lt;ol>
&lt;li>
&lt;p>这个字符串的长度应该是 2 的倍数&lt;/p>
&lt;p>显而易见，不是 2 的倍数的字符串里的括号一定不闭合&lt;/p>
&lt;/li>
&lt;li>
&lt;p>先出现的括号要在最后闭合&lt;/p>
&lt;p>这提示我们要使用 栈 这样的先入后出的数据结构&lt;/p>
&lt;/li>
&lt;/ol>
&lt;p>那么，我们先遍历字符串，让之中的左括号入栈直到遇到右括号&lt;/p>
&lt;p>让右括号匹配到它对于的左括号&lt;/p>
&lt;p>利用一个 map 即可&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Golang" data-lang="Golang">&lt;span class="nx">pairs&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="sc">&amp;#39;}&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="sc">&amp;#39;{&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="sc">&amp;#39;]&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="sc">&amp;#39;[&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="sc">&amp;#39;)&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="sc">&amp;#39;(&amp;#39;&lt;/span>&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>然后检查栈顶是否为对应的左括号&lt;/p>
&lt;p>是则让其出栈&lt;/p>
&lt;p>不是则这是非法字符串&lt;/p>
&lt;p>最终栈内元素为 0 时，字符串有效&lt;/p>
&lt;p>否则无效&lt;/p>
&lt;h2 id="题解">题解&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Golang" data-lang="Golang">&lt;span class="kd">func&lt;/span> &lt;span class="nf">isValid&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span> &lt;span class="kt">string&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">bool&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">%&lt;/span>&lt;span class="mi">2&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">pairs&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="kd">map&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="p">]&lt;/span>&lt;span class="kt">byte&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="sc">&amp;#39;}&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="sc">&amp;#39;{&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="sc">&amp;#39;]&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="sc">&amp;#39;[&amp;#39;&lt;/span>&lt;span class="p">,&lt;/span>
&lt;span class="sc">&amp;#39;)&amp;#39;&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="sc">&amp;#39;(&amp;#39;&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">stack&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">byte&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">:=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">_&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ok&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">pairs&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]]&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">ok&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stack&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">||&lt;/span> &lt;span class="nx">stack&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stack&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nx">pairs&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]]&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="kc">false&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">stack&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">stack&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stack&lt;/span>&lt;span class="p">)&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">stack&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stack&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">s&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">])&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">stack&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>先入后出 =&amp;gt; 栈&lt;/p>
&lt;p>匹配 =&amp;gt; Map&lt;/p></description></item><item><title>Leetcode 21 合成有序链表</title><link>https://fzxiao.top/posts/leetcode-21/</link><pubDate>Tue, 27 Oct 2020 20:09:54 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-21/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>将两个升序链表合并为一个新的 升序 链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。 &lt;/p>
&lt;p>示例：&lt;/p>
&lt;pre>&lt;code>输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4
输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4
&lt;/code>&lt;/pre>
&lt;h2 id="思路--题解">思路 &amp;amp;&amp;amp; 题解&lt;/h2>
&lt;p>这里我马上想到的是遍历&lt;/p>
&lt;p>根据所给条件&lt;/p>
&lt;p>我们遍历两链表&lt;/p>
&lt;p>例：&lt;/p>
&lt;pre>&lt;code>l1 = l1.Next
&lt;/code>&lt;/pre>
&lt;p>为了让新链表升序，我们需要比较当前节点数据的大小&lt;/p>
&lt;p>将更小的节点拼接在新链表上&lt;/p>
&lt;p>这里可以写出初步框架&lt;/p>
&lt;p>不妨设定头结点为 headNode&lt;/p>
&lt;p>结果链表为 result&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Golang" data-lang="Golang">&lt;span class="kd">func&lt;/span> &lt;span class="nf">mergeTowLists&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">l1&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ListNode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">l2&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ListNode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ListNode&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">headNode&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">ListNode&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="nx">result&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">headNode&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">l1&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">l2&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Val&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="nx">l2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Val&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">headNode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">ListNode&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">Val&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nx">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Val&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="nx">l1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">headNode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">ListNode&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">Val&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nx">l2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Val&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="nx">l2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">l2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">headNode&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">headNode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>遍历结束后&lt;/p>
&lt;p>必然存在一个链表不为 nil&lt;/p>
&lt;p>由于链表本身已是升序排列&lt;/p>
&lt;p>故只需将其链接在后即可&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Golang" data-lang="Golang"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">mergeTowLists&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">l1&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ListNode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">l2&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ListNode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ListNode&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">headNode&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">ListNode&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="nx">result&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">headNode&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">l1&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">l2&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Val&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="nx">l2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Val&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">headNode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">ListNode&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">Val&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nx">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Val&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="nx">l1&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">headNode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="o">&amp;amp;&lt;/span>&lt;span class="nx">ListNode&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="nx">Val&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="nx">l2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Val&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="nx">l2&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">l2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">headNode&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">headNode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">l1&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">headNode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">l2&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">headNode&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">l1&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">result&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>注 由于我们是从头结点开始拼接的，故应返回头结点的下一节点&lt;/p>
&lt;h2 id="总结">总结&lt;/h2>
&lt;p>第一次写链表题目，一时间被绕在里边了，不知道怎么切换节点 wwww&lt;/p>
&lt;p>只要把下一节点赋给当前节点变量就好了&lt;/p>
&lt;p>或许这题用递归写更合适？&lt;/p>
&lt;h2 id="递归解法">递归解法&lt;/h2>
&lt;p>一个递归总要有个结束条件&lt;/p>
&lt;p>我们的链表到底就是 nil 那么当l1, l2 两个链表都为 nil 的时候，递归应该结束&lt;/p>
&lt;p>即&lt;/p>
&lt;pre>&lt;code>if l1 == nil{
return l1
} else if l2 == nil {
return l2
}
&lt;/code>&lt;/pre>
&lt;p>再来分析递归的目的&lt;/p>
&lt;p>我们要使得最后生成的链表头最小&lt;/p>
&lt;p>那么递归就是找到最大值，将链表之后向前生成&lt;/p>
&lt;p>如下代码&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Golang" data-lang="Golang"> &lt;span class="k">if&lt;/span> &lt;span class="nx">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Val&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">l2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Val&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">mergeTwoLists&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">l2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">l1&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">l2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">mergeTwoLists&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">l1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">l2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">l2&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>举例&lt;/p>
&lt;p>l1 = [0,1]&lt;/p>
&lt;p>l2 = [1,2]&lt;/p>
&lt;pre>&lt;code>&amp;lt;1&amp;gt;
l1.Val(0) &amp;lt; l2.Val(1)
-&amp;gt;l1.Next(1), l2(1)
&amp;lt;2&amp;gt;
l1.Val(1) !&amp;lt; l2.Val(1)
-&amp;gt;l1(1), l2.Next(2)
&amp;lt;3&amp;gt;
l1.Val(1) &amp;lt; l2.Val(2)
-&amp;gt; l1.Next(nil), l2(2)
&amp;lt;4&amp;gt;
return l2(2)
l1.Next = l2(2)
return l1
l2.Next = l1(1)-&amp;gt;(2)
return l2
l1.Next = l2(1)-&amp;gt;l1(1)-&amp;gt;l2(2)
return l1
l1 = l1(0)-&amp;gt;l2(1)-&amp;gt;l1(1)-&amp;gt;l2(2)
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>-&amp;gt; 后表示传递给递归函数的值&lt;/p>
&lt;/blockquote>
&lt;p>完全代码如下&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Golang" data-lang="Golang">&lt;span class="kd">func&lt;/span> &lt;span class="nf">mergeTwoLists&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">l1&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ListNode&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">l2&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ListNode&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">*&lt;/span>&lt;span class="nx">ListNode&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">l1&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">l2&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nx">l2&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="kc">nil&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">l1&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Val&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">l2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Val&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">mergeTwoLists&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">l1&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">l2&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">l1&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">l2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nf">mergeTwoLists&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">l1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">l2&lt;/span>&lt;span class="p">.&lt;/span>&lt;span class="nx">Next&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">l2&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>递归是一种自顶而下的方法，我也觉得有些难懂，但多加练习，一定会变好的&lt;/p></description></item><item><title>Leetcode 54 螺旋矩阵 附 人生中的第一次面试：字节跳动</title><link>https://fzxiao.top/posts/leetcode-54/</link><pubDate>Tue, 20 Oct 2020 22:35:45 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-54/</guid><description>&lt;h2 id="背景">背景&lt;/h2>
&lt;p>身为一名大一的学生，却想着投实习简历玩，居然无意命中字节跳动&lt;/p>
&lt;p>于是乎，亲爱的面试官一题螺旋矩阵，让尚未刷题学习的我，成功回家等通知&lt;/p>
&lt;p>多说无意，好好学习，下面看题目&lt;/p>
&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给定一个包含 m x n 个元素的矩阵（m 行, n 列），请按照顺时针螺旋顺序，返回矩阵中的所有元素。&lt;/p>
&lt;p>示例 1:&lt;/p>
&lt;pre>&lt;code>输入:
[
[ 1, 2, 3 ],
[ 4, 5, 6 ],
[ 7, 8, 9 ]
]
输出: [1,2,3,6,9,8,7,4,5]
&lt;/code>&lt;/pre>
&lt;h2 id="分析">分析&lt;/h2>
&lt;p>正在面试的我，一脸懵逼，无从下手，面试官提示我这是一道很简单(本题难度中等)的题目 最后写了一点点，时间到了（菜 我 菜&lt;/p>
&lt;p>其实这个题目，只需要抓住矩阵的边界条件，就可以很明朗的解决&lt;/p>
&lt;p>不妨设输入矩阵为 matrix&lt;/p>
&lt;p>那么矩阵中的每一行下标 用 x 表示&lt;/p>
&lt;p>该行中的的元素下标 用 y 表示&lt;/p>
&lt;p>那么访问矩阵中的每一个元素即可表示为&lt;/p>
&lt;pre>&lt;code>element = matrix[x][y]
&lt;/code>&lt;/pre>
&lt;p>按照要求，我们需要螺旋的遍历这个矩阵&lt;/p>
&lt;p>遍历方向是 右 =&amp;gt; 下 =&amp;gt; 上 =&amp;gt; 左&lt;/p>
&lt;p>每次碰到边界，即转向&lt;/p>
&lt;p>循环直至完成遍历&lt;/p>
&lt;p>定义&lt;/p>
&lt;p>矩阵的行数 rows&lt;/p>
&lt;p>矩阵的列数 columns&lt;/p>
&lt;p>注意到 rows 等于矩阵数组的长度&lt;/p>
&lt;p>columns 等于 矩阵中一行的长度&lt;/p>
&lt;p>即&lt;/p>
&lt;pre>&lt;code>rows := len(matrix)
columns := len(matrix[0])
&lt;/code>&lt;/pre>
&lt;p>那么边界条件即为&lt;/p>
&lt;pre>&lt;code>0 &amp;lt;= x &amp;lt; rows
0 &amp;lt;= y &amp;lt; columns
&lt;/code>&lt;/pre>
&lt;p>那么向右遍历的实质是&lt;/p>
&lt;pre>&lt;code>x = x
y = y + 1
&lt;/code>&lt;/pre>
&lt;p>同理易得向下&lt;/p>
&lt;pre>&lt;code>x = x + 1
y = y
&lt;/code>&lt;/pre>
&lt;p>向左&lt;/p>
&lt;pre>&lt;code>x = x
y = y - 1
&lt;/code>&lt;/pre>
&lt;p>向上&lt;/p>
&lt;pre>&lt;code>x = x - 1
y = y
&lt;/code>&lt;/pre>
&lt;p>将方向控制抽象为两个数组&lt;/p>
&lt;pre>&lt;code>directionX := [0, 1, 0, -1]
directionY := [1, 0, -1, 0]
&lt;/code>&lt;/pre>
&lt;p>将改变方向定义为&lt;/p>
&lt;pre>&lt;code>directionIndex = 0
tx := x + directionX[directionIndex]
ty := y + directionY[directionIndex]
&lt;/code>&lt;/pre>
&lt;p>显然 tx, ty 即为新访问坐标，那么 directionIndex 是什么&lt;/p>
&lt;p>容易想到 directionIndex 的值 分别对应了不同的遍历方式&lt;/p>
&lt;p>需要转向时，只需让 directionIndex 自增 以切换到下一种改变方式&lt;/p>
&lt;p>Wait, 如果这样自增下去，directionIndex 就会越界&lt;/p>
&lt;p>解决方案如下&lt;/p>
&lt;pre>&lt;code>directionIndex = (directionIndex + 1) % 4
&lt;/code>&lt;/pre>
&lt;p>通过取模运算， 限制了 directionIndex 始终保持在方向数组的定义内&lt;/p>
&lt;p>这样就结束了吗，显然不是&lt;/p>
&lt;p>指针只是在最外圈打转而已，我们还需判断当前位置的元素是否已经访问过了&lt;/p>
&lt;p>引入一个新矩阵 visited，矩阵大小与原输入矩阵大小相同，用于标记是否访问过&lt;/p>
&lt;pre>&lt;code>visited := make([][]bool, rows)
for i:=0; i&amp;lt;rows; i++ {
visited[i] = make([]bool, columns)
}
&lt;/code>&lt;/pre>
&lt;p>我们还需要更新边界条件&lt;/p>
&lt;p>向原有的条件&lt;/p>
&lt;pre>&lt;code>0 &amp;lt;= x &amp;lt; rows
0 &amp;lt;= y &amp;lt; columns
&lt;/code>&lt;/pre>
&lt;p>后加入一条&lt;/p>
&lt;pre>&lt;code>visited[x][y] != true
&lt;/code>&lt;/pre>
&lt;p>这样，当遇到已经遍历过的元素时，也会触发转向&lt;/p>
&lt;p>综上述，我们来写代码&lt;/p>
&lt;h2 id="题解">题解&lt;/h2>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Golang" data-lang="Golang">&lt;span class="kd">func&lt;/span> &lt;span class="nf">spiralOrder&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">matrix&lt;/span> &lt;span class="p">[][]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="kd">var&lt;/span> &lt;span class="nx">result&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span> &lt;span class="c1">// 定义结果数组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">matrix&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 判空
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">return&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="nx">rows&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">columns&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">matrix&lt;/span>&lt;span class="p">),&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">matrix&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="c1">// 得到矩阵行，列数
&lt;/span>&lt;span class="c1">&lt;/span>
&lt;span class="c1">// 定义方向数组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">directionX&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="nx">directionY&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">{&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 定义方向变量
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">directionIndex&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="c1">// 定义访问矩阵
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">visited&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([][]&lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">rows&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">rows&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">visited&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">make&lt;/span>&lt;span class="p">([]&lt;/span>&lt;span class="kt">bool&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">columns&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="c1">// 定义访问坐标
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="kd">var&lt;/span> &lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="kt">int&lt;/span>
&lt;span class="c1">// 遍历，循环次数等于元素个数
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">rows&lt;/span>&lt;span class="o">*&lt;/span>&lt;span class="nx">columns&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">result&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">result&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">matrix&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="nx">y&lt;/span>&lt;span class="p">])&lt;/span> &lt;span class="c1">// 将 x, y 处元素加入结果数组
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">visited&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">x&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="nx">y&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="kc">true&lt;/span> &lt;span class="c1">// 设定 x, y 已被访问
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">tx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ty&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nx">x&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="nx">directionX&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">directionIndex&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="nx">y&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="nx">directionY&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">directionIndex&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="c1">// 获得下一访问坐标 tx, ty
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="k">if&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="nx">tx&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">tx&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">rows&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="mi">0&lt;/span> &lt;span class="o">&amp;lt;=&lt;/span> &lt;span class="nx">ty&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="nx">ty&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">columns&lt;/span> &lt;span class="o">&amp;amp;&amp;amp;&lt;/span> &lt;span class="p">!&lt;/span>&lt;span class="nx">visited&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">tx&lt;/span>&lt;span class="p">][&lt;/span>&lt;span class="nx">ty&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">{&lt;/span> &lt;span class="c1">// 判断边界条件
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">tx&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">ty&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="c1">// 切换方向
&lt;/span>&lt;span class="c1">&lt;/span> &lt;span class="nx">directionIndex&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="p">(&lt;/span>&lt;span class="nx">directionIndex&lt;/span> &lt;span class="o">+&lt;/span> &lt;span class="mi">1&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="o">%&lt;/span> &lt;span class="mi">4&lt;/span>
&lt;span class="nx">x&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">y&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">x&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="nx">directionX&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">directionIndex&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="nx">y&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="nx">directionY&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">directionIndex&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">result&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;p>涉及各种方式遍历的题目，无非就在考虑 边界条件 和 如何更改遍历方式&lt;/p></description></item><item><title>利用 Github Actions 和 Hugo 搭建自动化构建的静态博客</title><link>https://fzxiao.top/posts/build-blog-by-hugo/</link><pubDate>Sun, 11 Oct 2020 16:05:21 +0800</pubDate><guid>https://fzxiao.top/posts/build-blog-by-hugo/</guid><description>&lt;img src="https://fzxiao.top/posts/build-blog-by-hugo/build-blog-by-hugo-logo.png" alt="Featured image of post 利用 Github Actions 和 Hugo 搭建自动化构建的静态博客" />&lt;h2 id="前言">前言&lt;/h2>
&lt;p>既然刚折腾完 Hugo，蹭着记忆还清晰，梳理一下搭建过程吧&lt;/p>
&lt;h2 id="工具和网站介绍">工具和网站介绍&lt;/h2>
&lt;ul>
&lt;li>
&lt;p>&lt;a class="link" href="https://gohugo.io" target="_blank" rel="noopener"
>Hugo&lt;/a>:&lt;/p>
&lt;p>号称是世界上最快静态网页构建框架(framework)&lt;/p>
&lt;p>由 Go 编写而成，用于生成我们博客所需的静态页面&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://git-scm.com/" target="_blank" rel="noopener"
>Git&lt;/a>:&lt;/p>
&lt;p>Git 是一个分散式版本控制软件&lt;/p>
&lt;/li>
&lt;li>
&lt;p>&lt;a class="link" href="https://github.com" target="_blank" rel="noopener"
>Github&lt;/a>:&lt;/p>
&lt;p>&lt;del>最大的同性交友网站&lt;/del>
GitHub是通过Git进行版本控制的软件源代码托管服务平台&lt;/p>
&lt;p>本教程利用的是 Github 提供的名为 Github Pages 的免费网站托管服务&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="教程正文">教程正文&lt;/h2>
&lt;hr>
&lt;h3 id="step-0-安装-git-和-注册-github">Step 0: 安装 Git 和 注册 Github&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>安装 Git:&lt;/p>
&lt;p>打开 &lt;a class="link" href="https://git-scm.com/downloads" target="_blank" rel="noopener"
>Git&lt;/a> 页面，按照你的操作系统，下载安装程序，并安装&lt;/p>
&lt;/li>
&lt;li>
&lt;p>注册 Github:&lt;/p>
&lt;p>打开 &lt;a class="link" href="https://github.com/" target="_blank" rel="noopener"
>Github&lt;/a> 填写屏幕右侧的表单，跟随步骤进行即可&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="step-1-安装-hugo">Step 1: 安装 Hugo&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>Windows 用户:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>下载:&lt;/p>
&lt;p>前往&lt;a class="link" href="https://github.com/gohugoio/hugo/releases" target="_blank" rel="noopener"
>Releases&lt;/a>页面，查找名称类似于 &lt;strong>hugo_0.76.3_Windows-64bit.zip&lt;/strong> 的压缩包，下载解压即可&lt;/p>
&lt;p>请自行确定使用 x64/x86 版本&lt;/p>
&lt;/li>
&lt;li>
&lt;p>配置环境变量:&lt;/p>
&lt;p>右键开始菜单按钮&lt;/p>
&lt;p>选择系统&lt;/p>
&lt;p>在新打开的页面左侧中选择高级系统设置&lt;/p>
&lt;p>点击环境变量按钮&lt;/p>
&lt;p>在用户变量部分， 找到名为 PATH 的部分&lt;/p>
&lt;p>在 PATH 上双击&lt;/p>
&lt;p>点击添加按钮&lt;/p>
&lt;p>在弹出的窗口中选择含有 hugo.exe 文件的文件夹&lt;/p>
&lt;p>点击完成即可&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>Macos 用户:&lt;/p>
&lt;ul>
&lt;li>
&lt;p>如果你安装了 Brew：&lt;/p>
&lt;blockquote>
&lt;p>brew install hugo&lt;/p>
&lt;/blockquote>
&lt;p>在你喜欢的 Terminal 中执行上述命令即可&lt;/p>
&lt;/li>
&lt;li>
&lt;p>如果你未安装 Brew:&lt;/p>
&lt;p>前往&lt;a class="link" href="https://github.com/gohugoio/hugo/releases" target="_blank" rel="noopener"
>Releases&lt;/a>页面，查找名称类似于 &lt;strong>hugo_0.76.3_macOS-64bit.tar.gz&lt;/strong> 的压缩包并下载&lt;/p>
&lt;p>解压即可&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;/ul>
&lt;h3 id="step-2-利用-hugo-生成你的网站">Step 2: 利用 Hugo 生成你的网站&lt;/h3>
&lt;blockquote>
&lt;p>如果你进行此步骤遇到麻烦，请确认上一步骤是否正确进行&lt;/p>
&lt;/blockquote>
&lt;ul>
&lt;li>
&lt;p>打开 Terminal&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Windows:&lt;/p>
&lt;p>按下 win + x 键，选取 windows powershell&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Macos:&lt;/p>
&lt;p>根据喜好使用即可，笔者这里用的是 iTerm&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>生成新网站&lt;/p>
&lt;blockquote>
&lt;p>{var} 这样的标记，表示将此处替换成内部描述的字符，注意去掉{}&lt;/p>
&lt;/blockquote>
&lt;p>在 Terminal 下执行&lt;/p>
&lt;pre>&lt;code> &amp;gt;hugo new site {此处输入你要生成的网站目录名}
&lt;/code>&lt;/pre>
&lt;p>不出意外, 目录中已出现你指定名称的文件夹&lt;/p>
&lt;/li>
&lt;li>
&lt;p>选取 Blog 主题&lt;/p>
&lt;ul>
&lt;li>
&lt;p>下载主题&lt;/p>
&lt;p>可以在这个网站&lt;a class="link" href="https://themes.gohugo.io/" target="_blank" rel="noopener"
>Themes&lt;/a>或通过搜索引擎下载你喜欢的主题&lt;/p>
&lt;/li>
&lt;li>
&lt;p>安装主题&lt;/p>
&lt;p>下载后，主题应为一个压缩包，解压后放至网站目录内的 themes 文件夹内即可&lt;/p>
&lt;/li>
&lt;li>
&lt;p>配置主题&lt;/p>
&lt;p>鉴于不同主题配置方法不一，请参阅你选择的主题提供的文档&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>开始创作&lt;/p>
&lt;p>在 Terminal 内执行&lt;/p>
&lt;pre>&lt;code> &amp;gt;hugo new post/{文章名}.md
&lt;/code>&lt;/pre>
&lt;p>来创建文章文件&lt;/p>
&lt;blockquote>
&lt;p>注意：Hugo所使用的是名为 Markdown 的轻量型标记语言来撰写文章，如果你未接触过，这里提供一篇由少数派发布的&lt;a class="link" href="https://sspai.com/post/25137" target="_blank" rel="noopener"
>入门教程&lt;/a>&lt;/p>
&lt;/blockquote>
&lt;p>用你喜欢的编辑器打开该 md 文件，进行你的创作&lt;/p>
&lt;p>你应该已经注意到，md 文件开头有 以&amp;mdash;分割的一段信息(Meta)&lt;/p>
&lt;p>这段信息至少包含了三个部分&lt;/p>
&lt;ul>
&lt;li>
&lt;p>title&lt;/p>
&lt;/li>
&lt;li>
&lt;p>date&lt;/p>
&lt;/li>
&lt;li>
&lt;p>draft&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>后面跟随的值分别代表了&lt;/p>
&lt;ul>
&lt;li>文章标题&lt;/li>
&lt;li>生成日期&lt;/li>
&lt;li>是否为草稿&lt;/li>
&lt;/ul>
&lt;p>你可以自由修改前两部分&lt;/p>
&lt;p>如果你想让这篇文章显示在你的网站上的话，请将&lt;/p>
&lt;pre>&lt;code> draft: true
&lt;/code>&lt;/pre>
&lt;p>改为&lt;/p>
&lt;pre>&lt;code> draft: false
&lt;/code>&lt;/pre>
&lt;blockquote>
&lt;p>这个表示表明了这篇文章是否为草稿&lt;/p>
&lt;/blockquote>
&lt;p>创作完成后，保存文件即可&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="部署">部署&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>在本地预览你的博客&lt;/p>
&lt;p>在 Terminal 中执行&lt;/p>
&lt;pre>&lt;code> &amp;gt;hugo server
&lt;/code>&lt;/pre>
&lt;p>这样，hugo 会在本地搭建一个静态服务器来让你能够看到当前博客的样子&lt;/p>
&lt;/li>
&lt;li>
&lt;p>发布博客至 Github Pages&lt;/p>
&lt;p>仅让自己看到博客，不够尽兴，让大家都能一览你的作品吧&lt;/p>
&lt;ul>
&lt;li>
&lt;p>创建 Repo:&lt;/p>
&lt;p>要发布你的博客，首先需要在 Github 上创建一个库(repo)&lt;/p>
&lt;p>打开你的 Github 主页, 选择 New&lt;/p>
&lt;p>&lt;img src="https://fzxiao.top/imgs/build-blog-by-hugo/blog-1.png" alt="" />&lt;/p>
&lt;p>在新页面中，填入必要信息&lt;/p>
&lt;p>&lt;img src="https://fzxiao.top/imgs/build-blog-by-hugo/blog-2.png" alt="" />&lt;/p>
&lt;ul>
&lt;li>
&lt;p>Repositor name: 库的名称，此处建议使用 {github 用户名}.github.io 作为库名&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Description: 用一段简短的话描述这个库，可省略&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Public: 为了部署我们的网站，这个库的类型应该是公开的&lt;/p>
&lt;/li>
&lt;li>
&lt;p>Initialize this repository with: 此处的选项不在介绍，建议不勾选&lt;/p>
&lt;/li>
&lt;/ul>
&lt;p>点击绿色的 Create repository 来创建你的库&lt;/p>
&lt;/li>
&lt;li>
&lt;p>初始化本地 Git 库并 push 至 github&lt;/p>
&lt;p>回到 Terminal, 要想将网站发布，需要在本地创建 Git 库&lt;/p>
&lt;p>在网站根目录下依次执行&lt;/p>
&lt;pre>&lt;code> &amp;gt;git init
&amp;gt;git add .
&amp;gt;git commit -m &amp;quot;first commit&amp;quot;
&amp;gt;git remote add origin https://github.com/{你的 github 用户名}/{你的 github 用户名}.github.io.git
&amp;gt;git push -u origin master
&lt;/code>&lt;/pre>
&lt;p>这样，你的网站已经被上传到了 Github 上&lt;/p>
&lt;/li>
&lt;li>
&lt;p>配置 Github Actions&lt;/p>
&lt;p>hugo 的页面是需要静态生成后才能直接查看的，下面我们来配置 Github Actions&lt;/p>
&lt;p>在本帖网站根目录创建文件夹.github/workflows&lt;/p>
&lt;p>新建文件deploy.yml&lt;/p>
&lt;p>向文件中写入&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-yml" data-lang="yml">&lt;span class="c"># This is a basic workflow to help you get started with Actions&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">deploy-hugo&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c"># Controls when the action will run. Triggers the workflow on push or pull request&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c"># events but only for the master branch&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">push&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">branches&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">master ]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">pull_request&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">branches&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">master ]&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c"># A workflow run is made up of one or more jobs that can run sequentially or in parallel&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="nt">jobs&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">&lt;/span>&lt;span class="c"># This workflow contains a single job called &amp;#34;build&amp;#34;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">build&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># The type of runner that the job will run on&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">runs-on&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">ubuntu-latest&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Steps represent a sequence of tasks that will be executed as part of the job&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">steps&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># Checks-out your repository under $GITHUB_WORKSPACE, so your job can access it&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">actions/checkout@v2&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Setup Hugo # Step name&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">peaceiris/actions-hugo@v2 # Step 使用的 actions&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="c"># 參數設定&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">hugo-version&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="s1">&amp;#39;0.75.1&amp;#39;&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">extended&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="kc">true&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Build&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">run&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">hugo --gc --minify --cleanDestinationDir&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>- &lt;span class="nt">name&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">Deploy&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">uses&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">peaceiris/actions-gh-pages@v3&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">with&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">github_token&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">${{ secrets.GITHUB_TOKEN }}&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="nt">publish_dir&lt;/span>&lt;span class="p">:&lt;/span>&lt;span class="w"> &lt;/span>&lt;span class="l">./public&lt;/span>&lt;span class="w">
&lt;/span>&lt;span class="w">
&lt;/span>&lt;/code>&lt;/pre>&lt;/div>&lt;p>保存文件, 在 Terminal 中输入&lt;/p>
&lt;pre>&lt;code> &amp;gt;git add .
&amp;gt;git commit -m &amp;quot;init Actions&amp;quot;
&amp;gt;git push -u origin master
&lt;/code>&lt;/pre>
&lt;p>此时，Github Actions 会帮你生成文件后发布到 gh-pages 分支下&lt;/p>
&lt;/li>
&lt;li>
&lt;p>配置 Github Pages&lt;/p>
&lt;p>打开 Repo Setting 页面 &lt;a href="https://github.com/%7B">https://github.com/{&lt;/a>你的 github 用户名}/{你的 github 用户名}.github.io/settings&lt;/p>
&lt;p>&lt;img src="https://fzxiao.top/imgs/build-blog-by-hugo/blog-3.png" alt="" />&lt;/p>
&lt;p>找到图示部分，将原有的Branch: master 切换为 gh-pages 点击右侧 Save 保存即可&lt;/p>
&lt;/li>
&lt;/ul>
&lt;/li>
&lt;li>
&lt;p>大功告成&lt;/p>
&lt;p>打开 https://{你的 github 用户名}.github.io 来查看你的网站吧&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h3 id="后续创作">后续创作&lt;/h3>
&lt;ul>
&lt;li>
&lt;p>直接在 Github 上在线编辑&lt;/p>
&lt;p>打开你的 Repo 页面&lt;/p>
&lt;p>&lt;img src="https://fzxiao.top/imgs/build-blog-by-hugo/blog-4.png" alt="" />&lt;/p>
&lt;p>点击 Add file 选择 Create new file&lt;/p>
&lt;p>在打开的页面中&lt;/p>
&lt;p>&lt;img src="https://fzxiao.top/imgs/build-blog-by-hugo/blog-5.png" alt="" />&lt;/p>
&lt;p>向 Name your file 中输入 content/post/{文章名字}.md&lt;/p>
&lt;p>在下面的编辑框中创作，别忘了加上 Meta 信息&lt;/p>
&lt;p>创作完成后在页脚点击绿色的 commit new file 即可&lt;/p>
&lt;/li>
&lt;li>
&lt;p>在本地编辑器中创作&lt;/p>
&lt;p>回顾上文创作过程，创作完成后在 Terminal 中执行&lt;/p>
&lt;pre>&lt;code> &amp;gt;git add .
&amp;gt;git commit -m &amp;quot;{此处输入提示信息}&amp;quot;
&amp;gt;git push -u origin master
&lt;/code>&lt;/pre>
&lt;p>即可&lt;/p>
&lt;/li>
&lt;/ul>
&lt;h2 id="感谢">感谢&lt;/h2>
&lt;p>恭喜你学会了搭建博客的方法，其中夹杂了 CLI, Git, Markdown 等知识，如果你对这些感兴趣，可以自行了解&lt;/p>
&lt;p>感谢你阅读我的文章!&lt;/p></description></item><item><title>Leetcode 27 移除元素</title><link>https://fzxiao.top/posts/leetcode-27/</link><pubDate>Sat, 10 Oct 2020 19:46:46 +0800</pubDate><guid>https://fzxiao.top/posts/leetcode-27/</guid><description>&lt;h2 id="题目">题目&lt;/h2>
&lt;p>给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。&lt;/p>
&lt;p>不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并 原地 修改输入数组。&lt;/p>
&lt;p>元素的顺序可以改变。你不需要考虑数组中超出新长度后面的元素。&lt;/p>
&lt;h2 id="解析">解析&lt;/h2>
&lt;p>先来分享一下题目要求&lt;/p>
&lt;ul>
&lt;li>通过 原地修改数组 移除所给值&lt;/li>
&lt;li>元素顺序可改变&lt;/li>
&lt;li>返回数组长度 注：其实数组也是会被判定的，因为传入的是数组的引用&lt;/li>
&lt;/ul>
&lt;h3 id="第一解">第一解&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Golang" data-lang="Golang">&lt;span class="kd">func&lt;/span> &lt;span class="nf">removeElement&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">nums&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">:=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">nums&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">val&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">nums&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nb">append&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">nums&lt;/span>&lt;span class="p">[:&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">],&lt;/span> &lt;span class="nx">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="o">+&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">:]&lt;/span>&lt;span class="o">...&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">nums&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>第一次写下了这个解法，遍历数组，如果是需要移除的数，就移除，最后返回数组长度&lt;/p>
&lt;p>毫无疑问，这是个错解&lt;/p>
&lt;p>因为没有考虑移除元素后，指针i已经+1，导致漏过了中间的元素&lt;/p>
&lt;h3 id="第二解">第二解&lt;/h3>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Golang" data-lang="Golang">&lt;span class="kd">func&lt;/span> &lt;span class="nf">removeElement&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">nums&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">j&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">:=&lt;/span>&lt;span class="mi">0&lt;/span>&lt;span class="p">;&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="p">&amp;lt;&lt;/span>&lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">nums&lt;/span>&lt;span class="p">);&lt;/span> &lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">!=&lt;/span> &lt;span class="nx">val&lt;/span>&lt;span class="p">{&lt;/span>
&lt;span class="nx">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">j&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="p">=&lt;/span> &lt;span class="nx">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nx">j&lt;/span>&lt;span class="o">++&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">j&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;p>仔细阅读题目后，发现上一题还犯了一个错误：没有&lt;strong>原地修改数组&lt;/strong>&lt;/p>
&lt;p>因为其实使用 append 的过程中，是利用了 go 中 slice 的特性，创建了两个新数组然后合并&lt;/p>
&lt;p>那么，如果要原地修改数组的话，无疑是一个提示： &lt;strong>双指针&lt;/strong>&lt;/p>
&lt;p>这里定义两个指针 i, j 用快指针 i 来&lt;strong>遍历数组&lt;/strong>&lt;/p>
&lt;p>若得到的值并不是所给的需要移除的值，就将 i 处的元素放至 j 处，然后让慢指针 j 自增 1&lt;/p>
&lt;p>核心思想就在于 指针j 其实是在&lt;strong>创建&lt;/strong>答案所需的数组，只不过是覆盖原有元素来实现的&lt;/p>
&lt;p>那么当 指针i 遍历了整个数组后， 不需要删除的元素已经随着 指针j 创建好了， 而 j 正是数组的长度， 将其返回即可&lt;/p>
&lt;h3 id="第三解">第三解&lt;/h3>
&lt;p>LeetCode 官方还给出了另一种方法，考虑数组[1,2,3,3] 要移除的元素1&lt;/p>
&lt;p>因为移除的元素很少，但上面一个正解仍旧需要复制所有的非移除元素&lt;/p>
&lt;p>第三解解决了这个问题&lt;/p>
&lt;p>通过遍历数组，将最后一个元素放到当前需要元素上（效果等同于数组长度-1） 那么就能减少不需要移除的元素的复制&lt;/p>
&lt;div class="highlight">&lt;pre class="chroma">&lt;code class="language-Golang" data-lang="Golang"> &lt;span class="kd">func&lt;/span> &lt;span class="nf">removeElement&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">nums&lt;/span> &lt;span class="p">[]&lt;/span>&lt;span class="kt">int&lt;/span>&lt;span class="p">,&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="kt">int&lt;/span>&lt;span class="p">)&lt;/span> &lt;span class="kt">int&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">i&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="mi">0&lt;/span>
&lt;span class="nx">j&lt;/span> &lt;span class="o">:=&lt;/span> &lt;span class="nb">len&lt;/span>&lt;span class="p">(&lt;/span>&lt;span class="nx">nums&lt;/span>&lt;span class="p">)&lt;/span>
&lt;span class="k">for&lt;/span> &lt;span class="nx">i&lt;/span> &lt;span class="p">&amp;lt;&lt;/span> &lt;span class="nx">j&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="k">if&lt;/span> &lt;span class="nx">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">val&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">i&lt;/span>&lt;span class="p">]&lt;/span> &lt;span class="o">==&lt;/span> &lt;span class="nx">nums&lt;/span>&lt;span class="p">[&lt;/span>&lt;span class="nx">j&lt;/span>&lt;span class="o">-&lt;/span>&lt;span class="mi">1&lt;/span>&lt;span class="p">]&lt;/span>
&lt;span class="nx">j&lt;/span>&lt;span class="o">--&lt;/span>
&lt;span class="p">}&lt;/span> &lt;span class="k">else&lt;/span> &lt;span class="p">{&lt;/span>
&lt;span class="nx">i&lt;/span>&lt;span class="o">++&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;span class="k">return&lt;/span> &lt;span class="nx">j&lt;/span>
&lt;span class="p">}&lt;/span>
&lt;/code>&lt;/pre>&lt;/div>&lt;h2 id="总结">总结&lt;/h2>
&lt;ul>
&lt;li>类似原地修改数组的题目，都可以考虑用&lt;strong>双指针&lt;/strong>法&lt;/li>
&lt;li>原地移除数组元素不是不可实现的，可以考虑用文中的 用最后一个元素替换需要移除的元素 或 用双指针重写整个数组来实现&lt;/li>
&lt;/ul></description></item><item><title>Hello Hugo!</title><link>https://fzxiao.top/posts/hello_hugo/</link><pubDate>Sat, 10 Oct 2020 17:03:53 +0800</pubDate><guid>https://fzxiao.top/posts/hello_hugo/</guid><description>&lt;blockquote>
&lt;p>人活着就在于折腾&lt;/p>
&lt;/blockquote>
&lt;p>我总是把 blog 系统折腾来折腾去，经历了 Wp -&amp;gt; Hexo -&amp;gt; Jeklly -&amp;gt; Hugo&lt;/p>
&lt;p>但是文章却没好好写几篇wwww，这次换到了 Hugo 应该折腾到头了吧&lt;/p>
&lt;p>步入了大一，给自己一个从头开始吧（各种方面的）&lt;/p>
&lt;p>于是乎，这里既是新家啦，技术，日常什么的，就往这里放了吧(不知道又能坚持多久)&lt;/p>
&lt;p>总之&lt;/p>
&lt;blockquote>
&lt;p>Do what you love and love what you do.&lt;/p>
&lt;/blockquote>
&lt;p>让我们共勉吧&lt;/p></description></item></channel></rss>